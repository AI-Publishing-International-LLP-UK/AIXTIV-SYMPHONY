        id: doc.id,
        name: funnel.name,
        description: funnel.description,
        imageUrl: funnel.imageUrl,
        steps: funnel.steps.map(step => ({
          id: step.id,
          title: step.title,
          type: step.type
        })),
        startUrl: `/funnels/${doc.id}/start`,
        estimatedTimeMinutes: funnel.estimatedTimeMinutes,
        recommendationReason: 'Popular introduction for new users'
      };
    });
  } catch (error) {
    console.error('Error getting default funnels:', error);
    return [];
  }
}

/**
 * Detect region from request
 * 
 * @param {Object} deviceInfo - Device information
 * @returns {string} Detected region
 */
function detectRegionFromRequest(deviceInfo) {
  if (!deviceInfo) {
    return null;
  }
  
  // Try to determine region from language
  if (deviceInfo.language) {
    const languageMap = {
      'es': 'LATAM',
      'es-MX': 'Mexico',
      'es-ES': 'Spain',
      'en-GB': 'UK',
      'en-US': 'Global',
      'de': 'Europe',
      'fr': 'Europe',
      'it': 'Europe',
      'ja': 'Asia',
      'zh': 'Asia'
    };
    
    return languageMap[deviceInfo.language] || null;
  }
  
  // Try to determine region from timezone
  if (deviceInfo.timezone) {
    const timezoneMap = {
      'America/Mexico_City': 'Mexico',
      'Europe/London': 'UK',
      'Europe/Berlin': 'Europe',
      'Europe/Paris': 'Europe',
      'Europe/Madrid': 'Spain',
      'Asia/Tokyo': 'Asia',
      'Asia/Shanghai': 'Asia'
    };
    
    return timezoneMap[deviceInfo.timezone] || null;
  }
  
  return null;
}

// =====================================================
// COMMUNITY GENERATION
// =====================================================

/**
 * Community generation function
 * Automatically creates specialized communities based on segments
 * 
 * @param {Object} snapshot - Firestore document snapshot
 * @param {Object} context - Function context
 * @returns {null} No return value
 */
exports.generateCommunity = functions.firestore
  .document('communityRequests/{requestId}')
  .onCreate(async (snapshot, context) => {
    try {
      // Get request data
      const requestData = snapshot.data();
      const { name, segment, creator, description, region } = requestData;
      
      if (!name || !segment) {
        await snapshot.ref.update({
          status: 'error',
          message: 'Missing required fields: name and segment are required',
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        return null;
      }
      
      // Create community ID
      const communityId = name.toLowerCase().replace(/\s+/g, '-');
      
      // Check if community already exists
      const existingCommunityRef = db.collection('communities').doc(communityId);
      const existingCommunityDoc = await existingCommunityRef.get();
      
      if (existingCommunityDoc.exists) {
        await snapshot.ref.update({
          status: 'error',
          message: 'Community already exists',
          communityId: communityId,
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        return null;
      }
      
      // Get adaptation model if region is specified
      let adaptationModel = culturalAdaptationModels['Global'];
      if (region) {
        adaptationModel = culturalAdaptationModels[region] || culturalAdaptationModels['Global'];
      }
      
      // Generate community content using AI or rule-based generation
      let generatedContent;
      try {
        generatedContent = await generateAICommunityContent(name, segment, description, adaptationModel);
      } catch (error) {
        console.error('Error generating AI community content:', error);
        generatedContent = generateRuleBasedCommunityContent(name, segment, description, adaptationModel);
      }
      
      // Create community data
      const communityData = {
        name,
        segment,
        description: description || generatedContent.description,
        creator,
        topics: generatedContent.topics,
        resources: generatedContent.resources,
        welcomeMessage: generatedContent.welcomeMessage,
        rules: generatedContent.rules,
        faqs: generatedContent.faqs,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        members: creator ? [creator] : [],
        memberCount: creator ? 1 : 0,
        postCount: 0,
        isAutoGenerated: true,
        isPublic: true,
        status: 'active',
        region: region || null,
        culturalAdaptation: region ? {
          region,
          communicationStyle: adaptationModel.communicationStyle,
          valueEmphasis: adaptationModel.valueEmphasis
        } : null
      };
      
      // Create community in Firestore
      await existingCommunityRef.set(communityData);
      
      // If region is specified, create welcome post adapted to the region
      if (region) {
        const welcomePostContent = await generateRegionalWelcomePost(name, segment, region, adaptationModel);
        
        await db.collection('communityPosts').add({
          communityId,
          authorId: 'system',
          authorName: '2100 System',
          content: welcomePostContent,
          contentType: 'text',
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          isPinned: true,
          isWelcomePost: true,
          likes: 0,
          comments: 0
        });
      }
      
      // Update request status
      await snapshot.ref.update({
        status: 'completed',
        communityId: communityId,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Create community engagement suggestions
      await createCommunityEngagementSuggestions(communityId, segment);
      
      return null;
    } catch (error) {
      console.error('Error generating community:', error);
      
      // Update request with error
      await snapshot.ref.update({
        status: 'error',
        message: error.message,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      return null;
    }
  });

/**
 * Generate community content using OpenAI
 * 
 * @param {string} name - Community name
 * @param {string} segment - Community segment
 * @param {string} description - Community description
 * @param {Object} adaptationModel - Cultural adaptation model
 * @returns {Object} Generated community content
 */
async function generateAICommunityContent(name, segment, description, adaptationModel) {
  // Create prompt for OpenAI
  const prompt = `
You are a community development expert tasked with creating a specialized AI community for professionals.

Create content for a new online community with the following details:
- Name: ${name}
- Segment: ${segment}
- Description: ${description || "Not provided"}

The community will be on the 2100 platform, focused on AI transformation and professional development.
The target audience values ${adaptationModel.valueEmphasis.join(', ')} and prefers a ${adaptationModel.communicationStyle} communication style.

Please generate the following community elements:

1. A concise community description (if not provided)
2. 5-7 discussion topics that would be valuable for this community
3. 3-5 resources that would be helpful for community members
4. A welcoming message for new members (using ${adaptationModel.communicationStyle} style)
5. 5 community rules or guidelines
6. 3-4 frequently asked questions with answers

Format your response as structured JSON:
{
  "description": "Community description...",
  "topics": ["Topic 1", "Topic 2", ...],
  "resources": [
    {"title": "Resource 1", "type": "document/course/tool", "description": "Brief description..."},
    ...
  ],
  "welcomeMessage": "Welcome message...",
  "rules": ["Rule 1", "Rule 2", ...],
  "faqs": [
    {"question": "Question 1?", "answer": "Answer 1..."},
    ...
  ]
}
`;

  try {
    // Call OpenAI API
    const response = await openai.createCompletion({
      model: "text-davinci-003",
      prompt: prompt,
      max_tokens: 1500,
      temperature: 0.7,
    });
    
    // Parse the response
    const jsonMatch = response.data.choices[0].text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    // Fallback to rule-based generation if parsing fails
    throw new Error('Failed to parse OpenAI response');
  } catch (error) {
    console.error('OpenAI API error:', error);
    throw error;
  }
}

/**
 * Generate community content using rule-based approach
 * 
 * @param {string} name - Community name
 * @param {string} segment - Community segment
 * @param {string} description - Community description
 * @param {Object} adaptationModel - Cultural adaptation model
 * @returns {Object} Generated community content
 */
function generateRuleBasedCommunityContent(name, segment, description, adaptationModel) {
  // Extract segment parts
  const segmentParts = segment.split('-');
  const segmentType = segmentParts[0];
  const segmentValue = segmentParts[1];
  
  // Default description if not provided
  const communityDescription = description || 
    `A community for ${segmentValue} professionals exploring AI transformation and opportunities.`;
  
  // Generate topics based on segment
  let topics = [];
  let resources = [];
  
  // Topics by segment type
  if (segmentType === 'industry') {
    topics = [
      `AI Transformation in ${segmentValue}`,
      `${segmentValue} Case Studies`,
      `AI Regulations in ${segmentValue}`,
      `Career Development with AI in ${segmentValue}`,
      `${segmentValue} Tech Stack`,
      `AI Ethics in ${segmentValue}`,
      `Future of ${segmentValue} with AI`
    ];
    
    resources = [
      {
        title: `AI in ${segmentValue} - Whitepaper`,
        type: 'document',
        description: `Comprehensive overview of AI applications in the ${segmentValue} industry.`
      },
      {
        title: `${segmentValue} AI Transformation Roadmap`,
        type: 'template',
        description: `Step-by-step template for implementing AI in ${segmentValue} organizations.`
      },
      {
        title: `Learn AI for ${segmentValue} Professionals`,
        type: 'course',
        description: `Industry-specific AI training for ${segmentValue} professionals.`
      }
    ];
  } else if (segmentType === 'role') {
    topics = [
      `AI Tools for ${segmentValue}s`,
      `${segmentValue} Skills Enhancement`,
      `AI-Powered ${segmentValue} Workflows`,
      `Future of ${segmentValue} with AI`,
      `${segmentValue} Networking`,
      `${segmentValue} Career Advancement`,
      `AI Ethics for ${segmentValue}s`
    ];
    
    resources = [
      {
        title: `AI Toolkit for ${segmentValue}s`,
        type: 'toolkit',
        description: `Essential AI tools and resources for ${segmentValue} professionals.`
      },
      {
        title: `${segmentValue} AI Certification`,
        type: 'certification',
        description: `Specialized AI certification program for ${segmentValue}s.`
      },
      {
        title: `${segmentValue} AI Transformation Guide`,
        type: 'guide',
        description: `How to leverage AI to enhance your effectiveness as a ${segmentValue}.`
      }
    ];
  } else if (segmentType === 'geo') {
    topics = [
      `AI in ${segmentValue} - Regional Trends`,
      `${segmentValue} AI Regulations`,
      `Networking in ${segmentValue}`,
      `${segmentValue} Success Stories`,
      `AI Investment in ${segmentValue}`,
      `AI Education in ${segmentValue}`,
      `${segmentValue} AI Ecosystem`
    ];
    
    resources = [
      {
        title: `${segmentValue} AI Market Report`,
        type: 'report',
        description: `Comprehensive analysis of the AI market in ${segmentValue}.`
      },
      {
        title: `AI Events in ${segmentValue}`,
        type: 'events',
        description: `Calendar of upcoming AI conferences and meetups in ${segmentValue}.`
      },
      {
        title: `${segmentValue} AI Directory`,
        type: 'directory',
        description: `Directory of AI companies, professionals, and resources in ${segmentValue}.`
      }
    ];
  }
  
  // Generate welcome message based on adaptation model
  let welcomeMessage = '';
  
  if (adaptationModel.communicationStyle === 'relationship-focused') {
    welcomeMessage = `Welcome to our ${name} community! We're excited to have you join our journey exploring AI in ${segmentValue}. Together, we'll share insights, support each other's growth, and build meaningful connections. Don't hesitate to introduce yourself and share your experiences - we're all here to learn and grow together.`;
  } else if (adaptationModel.communicationStyle === 'direct-formal') {
    welcomeMessage = `Welcome to the ${name} community. This platform is designed to provide valuable insights and resources for ${segmentValue} professionals navigating AI transformation. Please review our guidelines, explore the resources, and contribute to discussions in your areas of expertise.`;
  } else if (adaptationModel.communicationStyle === 'indirect-harmonious') {
    welcomeMessage = `We're pleased to welcome you to the ${name} community, a space where harmony and collaboration guide our exploration of AI in ${segmentValue}. As you become familiar with our community, you might find value in the resources we've gathered and the perspectives shared by our members. When you feel ready, we would be honored to hear your insights.`;
  } else {
    welcomeMessage = `Welcome to the ${name} community! This is a space for professionals in ${segmentValue} to share insights, ask questions, and collaborate on AI initiatives. Feel free to browse our resources, join discussions, and connect with peers.`;
  }
  
  // Community rules
  const rules = [
    'Be respectful and professional in all interactions',
    'Share knowledge and insights that benefit the community',
    'No promotional content without prior permission',
    'Respect confidentiality and intellectual property',
    'Provide context and details when asking questions'
  ];
  
  // FAQs
  const faqs = [
    {
      question: `How can AI benefit ${segmentValue}?`,
      answer: `AI can enhance ${segmentValue} through automation, data analysis, and decision support tools, leading to improved efficiency, innovation, and competitive advantage.`
    },
    {
      question: 'How do I get started with AI in my organization?',
      answer: 'Begin with our introductory resources, identify specific use cases relevant to your organization, and consider starting with a small pilot project to demonstrate value.'
    },
    {
      question: 'Can I share job opportunities in this community?',
      answer: 'Yes, job opportunities related to AI in your field are welcome in the designated careers thread. Please include comprehensive details about the role, requirements, and application process.'
    },
    {
      question: 'How can I contribute to this community?',
      answer: 'You can contribute by sharing your experiences, responding to questions, providing resources, suggesting discussion topics, and participating in community events and challenges.'
    }
  ];
  
  return {
    description: communityDescription,
    topics,
    resources,
    welcomeMessage,
    rules,
    faqs
  };
}

/**
 * Generate a welcome post adapted to the region
 * 
 * @param {string} communityName - Community name
 * @param {string} segment - Community segment
 * @param {string} region - Target region
 * @param {Object} adaptationModel - Cultural adaptation model
 * @returns {string} Welcome post content
 */
async function generateRegionalWelcomePost(communityName, segment, region, adaptationModel) {
  // Extract segment value
  const segmentValue = segment.split('-')[1];
  
  // Generate post based on region and adaptation model
  if (adaptationModel.communicationStyle === 'relationship-focused') {
    return `
# Welcome to our ${communityName} community in ${region}!

We are thrilled to launch this community specifically for our ${region} members who are interested in ${segmentValue}. 

Together, we'll explore how AI is transforming ${segmentValue} in our unique regional context, sharing our collective wisdom and supporting each other through this journey of transformation.

## What makes our ${region} community special:

- Regional expertise and insights specific to ${region}
- Local case studies and success stories
- Region-specific regulations and best practices
- Opportunities to connect with peers in your area

We believe that by building strong relationships within our community, we can all achieve more than we could individually.

Please take a moment to introduce yourself and share what you hope to gain from this community!

Looking forward to growing together,

The 2100 Team
`;
  } else if (adaptationModel.communicationStyle === 'direct-formal') {
    return `
# ${communityName} - ${region} Chapter

Welcome to the official ${region} community for ${segmentValue} professionals.

This community serves as a dedicated resource for ${region} professionals navigating AI transformation in ${segmentValue}. You will find:

1. Region-specific resources and case studies
2. Regulatory and compliance information relevant to ${region}
3. Industry benchmarks and standards for our region
4. Networking opportunities with regional peers

## Expected outcomes for members:

- Enhanced knowledge of AI applications in ${segmentValue} specific to ${region}
- Practical implementation strategies tailored to regional context
- Professional network development within ${region}
- Access to region-specific events and opportunities

Please review the community guidelines and begin engaging with the resources provided.

Regards,
The 2100 Team
`;
  } else {
    return `
# Welcome to ${communityName} - ${region}

We're excited to welcome you to this community created specifically for ${segmentValue} professionals in ${region}.

This space brings together insights, resources, and discussions that reflect the unique aspects of AI transformation in our region. We hope this becomes a valuable resource for your professional journey.

## Community Highlights:

- Regional perspectives on AI in ${segmentValue}
- Resources tailored to ${region}'s market and regulatory environment
- Connections with fellow professionals in your region
- Local events and opportunities

Feel free to explore the topics, introduce yourself, and share your experiences. Every contribution enriches our community.

We look forward to your participation!

The 2100 Team
`;
  }
}

/**
 * Create engagement suggestions for a community
 * 
 * @param {string} communityId - Community ID
 * @param {string} segment - Community segment
 * @returns {Promise<void>} No return value
 */
async function createCommunityEngagementSuggestions(communityId, segment) {
  // Extract segment information
  const [segmentType, segmentValue] = segment.split('-');
  
  // Create engagement suggestions based on segment type
  const suggestions = [];
  
  if (segmentType === 'industry') {
    suggestions.push(
      {
        title: 'Share an Industry Case Study',
        description: `Share how an organization in the ${segmentValue} industry successfully implemented AI`,
        contentPrompt: `# [Company Name] AI Implementation Case Study\n\n## Challenge\n[Describe the business challenge]\n\n## Solution\n[Describe the AI solution implemented]\n\n## Results\n[Share the measurable outcomes]\n\n## Lessons Learned\n[Share insights gained from the implementation]`,
        type: 'discussion',
        suggestedFrequency: 'monthly'
      },
      {
        title: 'Industry Regulatory Update',
        description: `Discuss recent or upcoming regulatory changes affecting AI in ${segmentValue}`,
        contentPrompt: `# AI Regulatory Update for ${segmentValue}\n\n## Regulation Overview\n[Describe the regulation/policy]\n\n## Effective Date\n[When does/did it take effect?]\n\n## Key Requirements\n[Main compliance points]\n\n## Potential Impact\n[How might this affect organizations?]\n\n## Preparation Steps\n[What should companies do to prepare?]`,
        type: 'discussion',
        suggestedFrequency: 'quarterly'
      },
      {
        title: 'Technology Trend Spotlight',
        description: `Highlight an emerging AI technology trend relevant to ${segmentValue}`,
        contentPrompt: `# Emerging AI Trend in ${segmentValue}: [Technology Name]\n\n## What is it?\n[Describe the technology]\n\n## Why it matters\n[Relevance to the industry]\n\n## Early adopters\n[Who's using it already?]\n\n## Potential applications\n[How could it be applied?]\n\n## Getting started\n[Resources for learning more]`,
        type: 'discussion',
        suggestedFrequency: 'monthly'
      }
    );
  } else if (segmentType === 'role') {
    suggestions.push(
      {
        title: 'Role Evolution Discussion',
        description: `Discuss how the ${segmentValue} role is evolving with AI`,
        contentPrompt: `# The Evolving Role of ${segmentValue}s in the AI Era\n\n## Traditional responsibilities\n[List key responsibilities]\n\n## Emerging responsibilities\n[New areas of focus]\n\n## Skills gap\n[What new skills are needed?]\n\n## Career opportunities\n[New roles or paths emerging]\n\n## Your experience\n[Share your personal observations]`,
        type: 'discussion',
        suggestedFrequency: 'quarterly'
      },
      {
        title: 'Tool Recommendation',
        description: `Share an AI tool that has improved your effectiveness as a ${segmentValue}`,
        contentPrompt: `# AI Tool Spotlight: [Tool Name]\n\n## What it does\n[Tool purpose and features]\n\n## How I use it as a ${segmentValue}\n[Your specific use case]\n\n## Benefits I've experienced\n[Measurable improvements]\n\n## Limitations to be aware of\n[Things to watch out for]\n\n## Getting started\n[Basic steps to implement]`,
        type: 'resource',
        suggestedFrequency: 'monthly'
      },
      {
        title: 'Skill Development Challenge',
        description: `Propose a 30-day challenge to develop a specific AI-related skill for ${segmentValue}s`,
        contentPrompt: `# 30-Day Skill Challenge for ${segmentValue}s: [Skill Name]\n\n## Why this skill matters\n[Relevance to role]\n\n## Challenge structure\n[Day-by-day activities]\n\n## Resources needed\n[Tools, courses, etc.]\n\n## Success metrics\n[How to measure progress]\n\n## Who's joining me?\n[Call for participants]`,
        type: 'event',
        suggestedFrequency: 'quarterly'
      }
    );
  } else if (segmentType === 'geo') {
    suggestions.push(
      {
        title: 'Regional AI Ecosystem Map',
        description: `Create a collaborative map of AI organizations in ${segmentValue}`,
        contentPrompt: `# ${segmentValue} AI Ecosystem Map\n\n## Key AI providers\n[List companies and specialties]\n\n## AI-focused educational institutions\n[Universities, bootcamps, etc.]\n\n## Innovation hubs\n[Incubators, accelerators, coworking]\n\n## Government initiatives\n[Policies, funding, programs]\n\n## Notable startups\n[Emerging companies to watch]\n\n## Add your suggestions in the comments!`,
        type: 'resource',
        suggestedFrequency: 'annually'
      },
      {
        title: 'Regional Event Roundup',
        description: `Share upcoming AI events in ${segmentValue}`,
        contentPrompt: `# Upcoming AI Events in ${segmentValue}\n\n## Conferences\n[List with dates, locations, focus areas]\n\n## Workshops & Training\n[Skill-building opportunities]\n\n## Meetups\n[Recurring community gatherings]\n\n## Hackathons\n[Competitive events]\n\n## Online Events\n[Webinars, virtual conferences]\n\n## Add events in the comments!`,
        type: 'resource',
        suggestedFrequency: 'monthly'
      },
      {
        title: 'Local Success Story',
        description: `Highlight a ${segmentValue} organization successfully implementing AI`,
        contentPrompt: `# ${segmentValue} Success Story: [Organization Name]\n\n## Organization background\n[Brief history and context]\n\n## AI implementation\n[Technologies and approach]\n\n## Local challenges overcome\n[Region-specific obstacles]\n\n## Results achieved\n[Business outcomes]\n\n## Regional impact\n[Broader effects on local ecosystem]`,
        type: 'discussion',
        suggestedFrequency: 'monthly'
      }
    );
  }
  
  // Add generic engagement suggestions applicable to all segments
  suggestions.push(
    {
      title: 'Monthly Member Spotlight',
      description: 'Featured interview with an active community member',
      contentPrompt: `# Member Spotlight: [Member Name]\n\n## Professional background\n[Brief career journey]\n\n## Current focus\n[Role and priorities]\n\n## AI journey\n[Experience with AI adoption]\n\n## Biggest challenge\n[Current obstacle]\n\n## Biggest opportunity\n[Exciting possibility]\n\n## Advice for peers\n[Words of wisdom]\n\n## Connect with [Name]\n[Professional profiles, contact info]`,
      type: 'discussion',
      suggestedFrequency: 'monthly'
    },
    {
      title: 'Weekly Discussion Question',
      description: 'Thought-provoking question to stimulate conversation',
      contentPrompt: `# Discussion Question: [Compelling Question]\n\nI've been thinking about this question lately and would love to hear different perspectives from our community:\n\n**[Detailed version of question]**\n\nSome angles to consider:\n- [Aspect 1]\n- [Aspect 2]\n- [Aspect 3]\n\nI'll start by sharing my thoughts in the comments below. Looking forward to a thoughtful discussion!`,
      type: 'discussion',
      suggestedFrequency: 'weekly'
    }
  );
  
  // Save suggestions to Firestore
  const batch = db.batch();
  
  for (const suggestion of suggestions) {
    const suggestionRef = db.collection('communityEngagementSuggestions').doc();
    batch.set(suggestionRef, {
      ...suggestion,
      communityId,
      segment,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      status: 'active'
    });
  }
  
  await batch.commit();
}

// Export the Express apps as Firebase functions
exports.agentNFTs = functions.https.onRequest(nftApp);
exports.culturalAdaptation = functions.https.onRequest(app);

// Export the module for testing
module.exports = {
  analyzeCulturalFit,
  adaptContentForCulture,
  localizeAgentForRegion,
  calculateUserSegment,
  getRecommendedAgents,
  generateCommunityContent: generateRuleBasedCommunityContent,
  detectRegionFromRequest
};    const { nftId } = req.params;
    const { recipientAddress } = req.body;
    
    if (!recipientAddress) {
      return res.status(400).json({ 
        error: 'Bad Request', 
        message: 'Recipient address is required' 
      });
    }
    
    // Get NFT data
    const nftRef = db.collection('agentNFTs').doc(nftId);
    const nftDoc = await nftRef.get();
    
    if (!nftDoc.exists) {
      return res.status(404).json({ 
        error: 'Not Found', 
        message: 'NFT not found' 
      });
    }
    
    const nft = nftDoc.data();
    
    // Verify ownership
    if (nft.owner !== req.user.uid) {
      return res.status(403).json({ 
        error: 'Forbidden', 
        message: 'You do not own this NFT' 
      });
    }
    
    // Load contract for transfer
    const nftContractAddress = functions.config().nft.contract_address;
    const nftContractAbi = require('./abis/AgentNFT.json');
    const nftContract = new web3.eth.Contract(nftContractAbi, nftContractAddress);
    
    const wallet = web3.eth.accounts.wallet.add(functions.config().web3.private_key);
    
    // Transfer NFT
    const transferTx = await nftContract.methods.transferFrom(
      wallet.address,
      recipientAddress,
      nft.tokenId
    ).send({
      from: wallet.address,
      gas: 200000
    });
    
    // Update NFT data in Firestore
    await nftRef.update({
      owner: recipientAddress,
      lastTransferred: admin.firestore.FieldValue.serverTimestamp(),
      transferHistory: admin.firestore.FieldValue.arrayUnion({
        from: req.user.uid,
        to: recipientAddress,
        timestamp: new Date().toISOString(),
        transactionHash: transferTx.transactionHash
      })
    });
    
    res.json({
      success: true,
      nftId,
      tokenId: nft.tokenId,
      from: req.user.uid,
      to: recipientAddress,
      transactionHash: transferTx.transactionHash,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error transferring NFT:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Localize agent for a specific region
 * 
 * @param {Object} agent - The agent data
 * @param {string} region - The target region
 * @returns {Object} Localized agent data
 */
async function localizeAgentForRegion(agent, region) {
  // Get cultural adaptation model for the region
  const adaptationModel = culturalAdaptationModels[region] || culturalAdaptationModels['Global'];
  
  // Check if this agent already has a localization for this region
  const existingLocalizationSnapshot = await db.collection('agentLocalizations')
    .where('agentId', '==', agent.id)
    .where('region', '==', region)
    .limit(1)
    .get();
  
  // Return existing localization if available
  if (!existingLocalizationSnapshot.empty) {
    return {
      ...agent,
      ...existingLocalizationSnapshot.docs[0].data().localizedFields
    };
  }
  
  // Create a new localization
  const contentToAdapt = {
    title: agent.name,
    description: agent.description,
    examples: agent.examples || [],
    bodyContent: agent.profile || ''
  };
  
  try {
    // Use OpenAI to generate regional adaptation
    const adaptationPrompt = `
You are a cultural adaptation expert specializing in optimizing AI agent profiles for different global regions.

Please localize the following AI agent profile for the ${region} region. The target audience appreciates a ${adaptationModel.communicationStyle} communication style and values ${adaptationModel.valueEmphasis.join(', ')}.

AGENT PROFILE:
Name: ${agent.name}
Role: ${agent.role}
Description: ${agent.description}
Profile: ${agent.profile || "No detailed profile available"}
Capabilities: ${agent.capabilities.join(', ')}

Adapt ONLY the following elements for ${region} cultural preferences:
1. Name (if appropriate)
2. Description
3. Profile content

For the name, make minimal changes if needed - perhaps add a suffix or make subtle adjustments to better resonate with the region.

Provide your response in this JSON format:
{
  "name": "Localized name",
  "description": "Localized description",
  "profile": "Localized profile content"
}
`;

    const response = await openai.createCompletion({
      model: "text-davinci-003",
      prompt: adaptationPrompt,
      max_tokens: 1000,
      temperature: 0.7,
    });

    // Parse the adapted content from OpenAI response
    const jsonMatch = response.data.choices[0].text.match(/\{[\s\S]*\}/);
    let localizedFields = {};
    
    if (jsonMatch) {
      localizedFields = JSON.parse(jsonMatch[0]);
    } else {
      // Fallback localization if parsing fails
      localizedFields = {
        name: agent.name,
        description: `${agent.description} (${region} Edition)`,
        profile: agent.profile
      };
    }
    
    // Store localization in Firestore
    await db.collection('agentLocalizations').add({
      agentId: agent.id,
      region,
      localizedFields,
      createdAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Return localized agent
    return {
      ...agent,
      ...localizedFields
    };
  } catch (error) {
    console.error(`Error localizing agent for ${region}:`, error);
    
    // Return original agent with minor localization if AI fails
    return {
      ...agent,
      name: `${agent.name} (${region})`,
      description: `${agent.description} [${region} Edition]`
    };
  }
}

// =====================================================
// MOBILE APP CONFIGURATION
// =====================================================

/**
 * Mobile app configuration function
 * Provides personalized configuration for mobile app clients
 * 
 * @param {Object} data - Request data
 * @param {string} data.userId - User ID
 * @param {Object} data.deviceInfo - Device information
 * @param {string} data.userSegment - User segment information
 * @param {Object} context - Function context
 * @returns {Object} Personalized app configuration
 */
exports.mobileAppConfig = functions.https.onCall(async (data, context) => {
  try {
    const { userId, deviceInfo, userSegment, region } = data;
    
    // Verify authentication if userId provided
    if (userId && userId !== 'anonymous') {
      // If function is called with auth, verify it matches the requested userId
      if (context.auth && context.auth.uid !== userId) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'User ID does not match authenticated user'
        );
      }
      
      // Check if user exists
      const userRef = db.collection('users').doc(userId);
      const userDoc = await userRef.get();
      
      if (!userDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'User not found'
        );
      }
      
      const user = userDoc.data();
      
      // Generate app configuration based on user data
      const effectiveRegion = region || user.region || 'Global';
      const adaptationModel = culturalAdaptationModels[effectiveRegion] || culturalAdaptationModels['Global'];
      
      // Calculate user segments
      const segments = userSegment || calculateUserSegment(user, deviceInfo);
      
      // Get enabled features
      const features = await getEnabledFeatures(user);
      
      // Get recommended agents
      const recommendedAgents = await getRecommendedAgents(user, 3);
      
      // Get relevant communities
      const relevantCommunities = await getRelevantCommunities(user);
      
      // Generate personalized funnels
      const personalizedFunnels = await generatePersonalizedFunnels(user);
      
      // Generate app configuration
      const appConfig = {
        userId,
        region: effectiveRegion,
        language: user.language || 'en',
        segments,
        features,
        theme: adaptThemeForRegion(user.preferences?.theme || 'default', adaptationModel),
        layout: adaptLayoutForRegion(user.preferences?.layout || 'standard', adaptationModel),
        contentStyle: {
          communicationStyle: adaptationModel.communicationStyle,
          imagePreferences: adaptationModel.imagePreferences,
          contextLevel: adaptationModel.contextLevel,
          exampleStyle: adaptationModel.exampleStyle,
          valueEmphasis: adaptationModel.valueEmphasis
        },
        aiAgents: recommendedAgents,
        communities: relevantCommunities,
        funnels: personalizedFunnels,
        tutorials: shouldShowTutorials(user, deviceInfo)
      };
      
      // Log app configuration request
      await db.collection('appConfigRequests').add({
        userId,
        deviceInfo,
        region: effectiveRegion,
        segments,
        timestamp: admin.firestore.FieldValue.serverTimestamp()
      });
      
      return appConfig;
    } else {
      // Anonymous configuration
      const effectiveRegion = region || detectRegionFromRequest(deviceInfo) || 'Global';
      const adaptationModel = culturalAdaptationModels[effectiveRegion] || culturalAdaptationModels['Global'];
      
      // Generate anonymous app configuration
      return {
        userId: 'anonymous',
        region: effectiveRegion,
        language: deviceInfo?.language || 'en',
        segments: ['anonymous'],
        features: await getAnonymousFeatures(),
        theme: adaptThemeForRegion('default', adaptationModel),
        layout: adaptLayoutForRegion('standard', adaptationModel),
        contentStyle: {
          communicationStyle: adaptationModel.communicationStyle,
          imagePreferences: adaptationModel.imagePreferences,
          contextLevel: adaptationModel.contextLevel,
          exampleStyle: adaptationModel.exampleStyle,
          valueEmphasis: adaptationModel.valueEmphasis
        },
        aiAgents: await getPopularAgents(3),
        communities: await getPublicCommunities(3),
        funnels: await getDefaultFunnels(),
        tutorials: true
      };
    }
  } catch (error) {
    console.error('Error generating mobile app config:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

/**
 * Calculate user segment based on profile and behavior
 * 
 * @param {Object} user - User data
 * @param {Object} deviceInfo - Device information
 * @returns {Array} User segments
 */
function calculateUserSegment(user, deviceInfo) {
  const segments = [];
  
  // Industry segment
  if (user.industry) {
    segments.push(`industry-${user.industry.toLowerCase()}`);
  }
  
  // Role segment
  if (user.role) {
    segments.push(`role-${user.role.toLowerCase()}`);
  }
  
  // Career stage segment
  if (user.careerStage) {
    segments.push(`career-${user.careerStage.toLowerCase()}`);
  }
  
  // Geographic segment
  if (user.country) {
    segments.push(`geo-${user.country.toLowerCase()}`);
    
    // Regional segments
    if (['mx', 'co', 'ar', 'cl', 'pe', 'br'].includes(user.country.toLowerCase())) {
      segments.push('geo-latam');
    } else if (['gb', 'de', 'fr', 'es', 'it', 'nl'].includes(user.country.toLowerCase())) {
      segments.push('geo-europe');
    }
  }
  
  // Language segment
  if (user.language) {
    segments.push(`lang-${user.language.toLowerCase()}`);
  }
  
  // AI interest segment
  if (user.aiInterests && user.aiInterests.length > 0) {
    user.aiInterests.forEach(interest => {
      segments.push(`ai-${interest.toLowerCase()}`);
    });
  }
  
  // Behavior-based segments
  if (user.behavior) {
    if (user.behavior.loginFrequency > 5) {
      segments.push('behavior-power-user');
    }
    
    if (user.behavior.completedCourses > 0) {
      segments.push('behavior-learner');
    }
    
    if (user.behavior.communityPosts > 0) {
      segments.push('behavior-contributor');
    }
  }
  
  // Subscription segment
  if (user.subscription) {
    segments.push(`plan-${user.subscription.plan.toLowerCase()}`);
  }
  
  // Device segment
  if (deviceInfo?.platform) {
    segments.push(`device-${deviceInfo.platform.toLowerCase()}`);
  }
  
  return segments;
}

/**
 * Get enabled features for a user
 * 
 * @param {Object} user - User data
 * @returns {Object} Enabled features
 */
async function getEnabledFeatures(user) {
  // Basic features available to all users
  const features = {
    darkMode: true,
    contentSaving: true,
    basicAgents: true,
    publicCommunities: true,
    basicLearning: true
  };
  
  // Features based on subscription
  if (user.subscription) {
    if (['pro', 'enterprise', 'premium'].includes(user.subscription.plan.toLowerCase())) {
      features.advancedAgents = true;
      features.customizableAgents = true;
      features.privateCommunities = true;
      features.advancedLearning = true;
      features.dataExport = true;
    }
    
    if (['enterprise'].includes(user.subscription.plan.toLowerCase())) {
      features.teamManagement = true;
      features.customAnalytics = true;
      features.apiAccess = true;
      features.dedicatedSupport = true;
    }
  }
  
  // Features based on user behavior
  if (user.behavior) {
    if (user.behavior.completedCourses > 3) {
      features.advancedLearningPaths = true;
    }
    
    if (user.behavior.communityPosts > 10) {
      features.communityModeration = true;
    }
  }
  
  // Get any additional features from feature flags collection
  try {
    const featureFlagsSnapshot = await db.collection('featureFlags')
      .where('userId', '==', user.id)
      .get();
    
    featureFlagsSnapshot.docs.forEach(doc => {
      const flag = doc.data();
      features[flag.feature] = flag.enabled;
    });
  } catch (error) {
    console.error('Error fetching feature flags:', error);
  }
  
  return features;
}

/**
 * Get recommended agents for a user
 * 
 * @param {Object} user - User data
 * @param {number} limit - Maximum number of agents to return
 * @returns {Array} Recommended agents
 */
async function getRecommendedAgents(user, limit = 3) {
  try {
    // Get all agents
    const agentsSnapshot = await db.collection('agentProfiles')
      .where('status', '==', 'active')
      .get();
    
    // Convert to array with ID
    const agents = agentsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    // Score agents based on user profile match
    const scoredAgents = agents.map(agent => {
      let score = 0;
      
      // Industry match
      if (user.industry && agent.industries && 
          agent.industries.includes(user.industry)) {
        score += 10;
      }
      
      // Role match
      if (user.role && agent.recommendedRoles && 
          agent.recommendedRoles.includes(user.role)) {
        score += 8;
      }
      
      // Career stage match
      if (user.careerStage && agent.recommendedCareerStages && 
          agent.recommendedCareerStages.includes(user.careerStage)) {
        score += 8;
      }
      
      // Interest match
      if (user.aiInterests && agent.aiTopics) {
        const matchedInterests = user.aiInterests.filter(interest => 
          agent.aiTopics.includes(interest)
        );
        score += matchedInterests.length * 3;
      }
      
      // Region match
      if (user.region && agent.regions && 
          agent.regions.includes(user.region)) {
        score += 5;
      }
      
      // Language match
      if (user.language && agent.languages && 
          agent.languages.includes(user.language)) {
        score += 5;
      }
      
      // Popularity factor
      score += (agent.popularityScore || 0) * 0.5;
      
      return {
        ...agent,
        score
      };
    });
    
    // Sort by score and limit results
    return scoredAgents
      .sort((a, b) => b.score - a.score)
      .slice(0, limit)
      .map(agent => ({
        id: agent.id,
        name: agent.name,
        role: agent.role,
        description: agent.description,
        imageUrl: agent.imageUrl,
        capabilities: agent.capabilities,
        matchScore: Math.min(100, Math.round(agent.score * 2))
      }));
  } catch (error) {
    console.error('Error getting recommended agents:', error);
    return [];
  }
}

/**
 * Get relevant communities for a user
 * 
 * @param {Object} user - User data
 * @returns {Array} Relevant communities
 */
async function getRelevantCommunities(user) {
  try {
    // Get all communities
    const communitiesSnapshot = await db.collection('communities')
      .where('status', '==', 'active')
      .get();
    
    // Convert to array with ID
    const communities = communitiesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    // Score communities based on user profile match
    const scoredCommunities = communities.map(community => {
      let score = 0;
      
      // Segment match
      if (community.segment) {
        const segmentParts = community.segment.split('-');
        if (segmentParts.length === 2) {
          const [segmentType, segmentValue] = segmentParts;
          
          if (segmentType === 'industry' && user.industry === segmentValue) {
            score += 10;
          } else if (segmentType === 'role' && user.role === segmentValue) {
            score += 10;
          } else if (segmentType === 'geo' && user.country === segmentValue) {
            score += 10;
          }
        }
      }
      
      // User is already a member
      if (community.members && community.members.includes(user.id)) {
        score += 15;
      }
      
      // Community is popular
      score += (community.memberCount || 0) * 0.01;
      
      // Active community
      score += (community.postCount || 0) * 0.005;
      
      return {
        ...community,
        score
      };
    });
    
    // Sort by score and limit results
    return scoredCommunities
      .sort((a, b) => b.score - a.score)
      .slice(0, 5)
      .map(community => ({
        id: community.id,
        name: community.name,
        description: community.description,
        memberCount: community.memberCount || 0,
        imageUrl: community.imageUrl,
        segment: community.segment,
        isMember: community.members?.includes(user.id) || false
      }));
  } catch (error) {
    console.error('Error getting relevant communities:', error);
    return [];
  }
}

/**
 * Generate personalized funnels for a user
 * 
 * @param {Object} user - User data
 * @returns {Array} Personalized funnels
 */
async function generatePersonalizedFunnels(user) {
  try {
    // Get pre-defined funnels from Firestore
    const funnelsSnapshot = await db.collection('contentFunnels').get();
    
    // Convert to array with ID
    const funnels = funnelsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    // Score funnels based on user profile match
    const scoredFunnels = funnels.map(funnel => {
      let score = 0;
      
      // Target industry match
      if (funnel.targetIndustries && user.industry && 
          funnel.targetIndustries.includes(user.industry)) {
        score += 10;
      }
      
      // Target role match
      if (funnel.targetRoles && user.role && 
          funnel.targetRoles.includes(user.role)) {
        score += 10;
      }
      
      // Target career stage match
      if (funnel.targetCareerStages && user.careerStage && 
          funnel.targetCareerStages.includes(user.careerStage)) {
        score += 8;
      }
      
      // Target region match
      if (funnel.targetRegions && user.region && 
          funnel.targetRegions.includes(user.region)) {
        score += 5;
      }
      
      // Engagement history
      if (user.completedFunnels && user.completedFunnels.includes(funnel.id)) {
        score -= 20; // Penalize already completed funnels
      }
      
      if (user.startedFunnels && user.startedFunnels.includes(funnel.id)) {
        score += 5; // Boost started but not completed funnels
      }
      
      return {
        ...funnel,
        score
      };
    });
    
    // Sort by score and limit results
    return scoredFunnels
      .sort((a, b) => b.score - a.score)
      .slice(0, 3)
      .map(funnel => ({
        id: funnel.id,
        name: funnel.name,
        description: funnel.description,
        imageUrl: funnel.imageUrl,
        steps: funnel.steps.map(step => ({
          id: step.id,
          title: step.title,
          type: step.type
        })),
        startUrl: `/funnels/${funnel.id}/start`,
        estimatedTimeMinutes: funnel.estimatedTimeMinutes,
        recommendationReason: getRecommendationReason(funnel, user)
      }));
  } catch (error) {
    console.error('Error generating personalized funnels:', error);
    return [];
  }
}

/**
 * Get recommendation reason for a funnel
 * 
 * @param {Object} funnel - Funnel data
 * @param {Object} user - User data
 * @returns {string} Recommendation reason
 */
function getRecommendationReason(funnel, user) {
  if (funnel.targetIndustries && funnel.targetIndustries.includes(user.industry)) {
    return `Recommended for ${user.industry} professionals`;
  }
  
  if (funnel.targetRoles && funnel.targetRoles.includes(user.role)) {
    return `Designed for ${user.role}s like you`;
  }
  
  if (funnel.targetCareerStages && funnel.targetCareerStages.includes(user.careerStage)) {
    return `Perfect for your ${user.careerStage} career stage`;
  }
  
  if (user.startedFunnels && user.startedFunnels.includes(funnel.id)) {
    return 'Continue where you left off';
  }
  
  return 'Popular with users like you';
}

/**
 * Check if tutorials should be shown
 * 
 * @param {Object} user - User data
 * @param {Object} deviceInfo - Device information
 * @returns {boolean} Whether tutorials should be shown
 */
function shouldShowTutorials(user, deviceInfo) {
  // Always show tutorials to new users
  if (!user.lastLogin) {
    return true;
  }
  
  // Always show tutorials on new devices
  if (!user.knownDevices || !user.knownDevices.includes(deviceInfo?.deviceId)) {
    return true;
  }
  
  // Show tutorials if user has completed less than 3 tasks
  if (!user.completedTasks || user.completedTasks < 3) {
    return true;
  }
  
  // Otherwise, respect user preference
  return user.preferences?.showTutorials !== false;
}

/**
 * Adapt theme for region
 * 
 * @param {string} theme - User's theme preference
 * @param {Object} adaptationModel - The cultural adaptation model
 * @returns {Object} Adapted theme
 */
function adaptThemeForRegion(theme, adaptationModel) {
  // Base theme values
  const baseTheme = {
    primary: '#0055AA',
    secondary: '#00AA55',
    accent: '#AA5500',
    background: '#FFFFFF',
    text: '#333333',
    fontFamily: '"Roboto", sans-serif'
  };
  
  // Region-specific adaptations
  const regionThemeAdaptations = {
    'relationship-focused': {
      // Warmer, more vibrant colors for relationship-focused cultures
      primary: '#0066CC',
      secondary: '#00CC66',
      accent: '#CC6600'
    },
    'direct-formal': {
      // More subdued, professional colors for direct-formal cultures
      primary: '#003366',
      secondary: '#336633',
      accent: '#663300'
    },
    'indirect-harmonious': {
      // Balanced, harmonious colors for indirect-harmonious cultures
      primary: '#3355AA',
      secondary: '#55AA33',
      accent: '#AA3355'
    }
  };
  
  // Apply region-specific adaptation
  const adaptedBaseTheme = {
    ...baseTheme,
    ...regionThemeAdaptations[adaptationModel.communicationStyle] || {}
  };
  
  // Override with user's theme preference if not 'default'
  if (theme !== 'default') {
    return {
      ...adaptedBaseTheme,
      themeName: theme
    };
  }
  
  return {
    ...adaptedBaseTheme,
    themeName: 'regional'
  };
}

/**
 * Adapt layout for region
 * 
 * @param {string} layout - User's layout preference
 * @param {Object} adaptationModel - The cultural adaptation model
 * @returns {Object} Adapted layout
 */
function adaptLayoutForRegion(layout, adaptationModel) {
  // Base layout values
  const baseLayout = {
    density: 'medium',
    cardStyle: 'rounded',
    navigationPosition: 'bottom',
    sidebarVisible: true
  };
  
  // Region-specific adaptations
  const regionLayoutAdaptations = {
    'high-context': {
      // More visual elements for high-context cultures
      density: 'high',
      cardStyle: 'elevated'
    },
    'low-context': {
      // More explicit, structured layouts for low-context cultures
      density: 'low',
      cardStyle: 'flat'
    },
    'medium-context': {
      // Balanced layout for medium-context cultures
      density: 'medium',
      cardStyle: 'rounded'
    }
  };
  
  // Apply region-specific adaptation
  const adaptedBaseLayout = {
    ...baseLayout,
    ...regionLayoutAdaptations[adaptationModel.contextLevel] || {}
  };
  
  // Override with user's layout preference if not 'standard'
  if (layout !== 'standard') {
    return {
      ...adaptedBaseLayout,
      layoutName: layout
    };
  }
  
  return {
    ...adaptedBaseLayout,
    layoutName: 'regional'
  };
}

/**
 * Get anonymous features
 * 
 * @returns {Object} Features available to anonymous users
 */
async function getAnonymousFeatures() {
  return {
    darkMode: true,
    contentSaving: false,
    basicAgents: true,
    publicCommunities: true,
    basicLearning: true
  };
}

/**
 * Get popular agents
 * 
 * @param {number} limit - Maximum number of agents to return
 * @returns {Array} Popular agents
 */
async function getPopularAgents(limit = 3) {
  try {
    const agentsSnapshot = await db.collection('agentProfiles')
      .where('status', '==', 'active')
      .orderBy('popularityScore', 'desc')
      .limit(limit)
      .get();
    
    return agentsSnapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      role: doc.data().role,
      description: doc.data().description,
      imageUrl: doc.data().imageUrl,
      capabilities: doc.data().capabilities
    }));
  } catch (error) {
    console.error('Error getting popular agents:', error);
    return [];
  }
}

/**
 * Get public communities
 * 
 * @param {number} limit - Maximum number of communities to return
 * @returns {Array} Public communities
 */
async function getPublicCommunities(limit = 3) {
  try {
    const communitiesSnapshot = await db.collection('communities')
      .where('status', '==', 'active')
      .where('isPublic', '==', true)
      .orderBy('memberCount', 'desc')
      .limit(limit)
      .get();
    
    return communitiesSnapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      description: doc.data().description,
      memberCount: doc.data().memberCount || 0,
      imageUrl: doc.data().imageUrl,
      segment: doc.data().segment
    }));
  } catch (error) {
    console.error('Error getting public communities:', error);
    return [];
  }
}

/**
 * Get default funnels
 * 
 * @returns {Array} Default funnels for anonymous users
 */
async function getDefaultFunnels() {
  try {
    const funnelsSnapshot = await db.collection('contentFunnels')
      .where('isPublic', '==', true)
      .limit(2)
      .get();
    
    return funnelsSnapshot.docs.map(doc => {
      const funnel = doc.data();
      return {
        id:  // Calculate alignment score (weighted by position)
  let alignmentScore = 0;
  let maxPossibleScore = 0;
  
  // Values mentioned earlier are weighted more heavily
  for (let i = 0; i < Math.min(currentValues.length, 4); i++) {
    const weight = 1 - (i * 0.15); // Weights: 1.0, 0.85, 0.7, 0.55
    maxPossibleScore += weight;
    
    if (targetValues.includes(currentValues[i])) {
      alignmentScore += weight;
    }
  }
  
  return maxPossibleScore > 0 ? alignmentScore / maxPossibleScore : 0.5;
}

/**
 * Determine the fit level based on score
 * 
 * @param {number} score - The fit score (0-1)
 * @returns {string} The fit level descriptor
 */
function getFitLevel(score) {
  if (score >= 0.8) return 'excellent';
  if (score >= 0.6) return 'good';
  if (score >= 0.4) return 'fair';
  return 'needs-improvement';
}

/**
 * Generate cultural adaptation recommendations
 * 
 * @param {number} overallScore - The overall cultural fit score
 * @param {Object} analysis - The dimensional analysis results
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} targetRegion - The target region
 * @returns {Array} Prioritized recommendations
 */
function generateCulturalAdaptationRecommendations(overallScore, analysis, adaptationModel, targetRegion) {
  const recommendations = [];
  
  // Add recommendations based on analysis dimensions
  if (analysis.communicationStyle.score < 0.7) {
    recommendations.push({
      dimension: 'communicationStyle',
      importance: 'high',
      recommendation: `Adjust communication style to be more ${adaptationModel.communicationStyle} to better resonate with ${targetRegion} audiences.`,
      examples: getCommunicationStyleExamples(adaptationModel.communicationStyle)
    });
  }
  
  if (analysis.imageStyle.score < 0.7) {
    recommendations.push({
      dimension: 'imageStyle',
      importance: 'medium',
      recommendation: `Consider using images that reflect ${adaptationModel.imagePreferences} aesthetic, which is preferred in ${targetRegion}.`,
      examples: getImageStyleExamples(adaptationModel.imagePreferences)
    });
  }
  
  if (analysis.contextLevel.score < 0.7) {
    recommendations.push({
      dimension: 'contextLevel',
      importance: 'medium',
      recommendation: `Adjust the level of context in your content to be more ${adaptationModel.contextLevel}, which is typical for ${targetRegion} audiences.`,
      examples: getContextLevelExamples(adaptationModel.contextLevel)
    });
  }
  
  if (analysis.exampleStyle.score < 0.7) {
    recommendations.push({
      dimension: 'exampleStyle',
      importance: 'medium',
      recommendation: `Use ${adaptationModel.exampleStyle} examples in your content to better connect with audiences in ${targetRegion}.`,
      examples: getExampleStyleExamples(adaptationModel.exampleStyle)
    });
  }
  
  if (analysis.valueAlignment.score < 0.6) {
    const missingValues = adaptationModel.valueEmphasis
      .filter(value => !analysis.valueAlignment.currentEmphasis.includes(value));
    
    if (missingValues.length > 0) {
      recommendations.push({
        dimension: 'valueEmphasis',
        importance: 'high',
        recommendation: `Incorporate cultural values important in ${targetRegion}: ${missingValues.join(', ')}.`,
        examples: getValueEmphasisExamples(missingValues)
      });
    }
  }
  
  // Sort recommendations by importance
  const importanceOrder = { 'high': 0, 'medium': 1, 'low': 2 };
  recommendations.sort((a, b) => importanceOrder[a.importance] - importanceOrder[b.importance]);
  
  return recommendations;
}

/**
 * Generate examples for communication style adaptation
 * 
 * @param {string} style - The target communication style
 * @returns {Array} Example adaptations
 */
function getCommunicationStyleExamples(style) {
  const examples = {
    'direct-formal': [
      { before: "You might want to consider our solution", after: "Our solution will deliver these specific benefits" },
      { before: "We hope this helps with your goals", after: "This will help you achieve your goals through these measurable improvements" }
    ],
    'direct-yet-polite': [
      { before: "Our product is the best option", after: "We believe our product would be an excellent fit for your needs" },
      { before: "You should implement these changes", after: "These changes would significantly improve your results" }
    ],
    'relationship-focused': [
      { before: "This product increases efficiency by 25%", after: "Together, we can use this product to help your team achieve 25% greater efficiency" },
      { before: "The data shows clear benefits", after: "Our partnership will be strengthened by the benefits this solution brings to your team" }
    ],
    'indirect-harmonious': [
      { before: "You need to change your approach", after: "One possibility might be to consider a different approach that aligns with your goals" },
      { before: "This is the wrong strategy", after: "Perhaps exploring alternative strategies might reveal additional opportunities" }
    ],
    'expressive-relationship': [
      { before: "Our solution offers these features", after: "Imagine how our solution will transform your team's experience with these exciting features!" },
      { before: "The implementation process has 3 steps", after: "We'll embark on this journey together through 3 collaborative implementation steps" }
    ],
    'balanced': [
      { before: "Technical specifications are as follows", after: "Here are the technical specifications, designed with your team's needs in mind" },
      { before: "Our process is highly effective", after: "Our effective process delivers results while building a foundation for ongoing collaboration" }
    ]
  };
  
  return examples[style] || examples['balanced'];
}

/**
 * Generate examples for image style adaptation
 * 
 * @param {string} style - The target image style
 * @returns {Array} Example adaptations
 */
function getImageStyleExamples(style) {
  return [
    `Use images that reflect a ${style} aesthetic`,
    `Select visuals that incorporate the elements of ${style}`
  ];
}

/**
 * Generate examples for context level adaptation
 * 
 * @param {string} level - The target context level
 * @returns {Array} Example adaptations
 */
function getContextLevelExamples(level) {
  const examples = {
    'high-context': [
      "Provide more background and contextual information",
      "Focus on the 'why' behind actions and decisions",
      "Include historical or traditional perspectives"
    ],
    'medium-context': [
      "Balance explicit information with contextual elements",
      "Include some background while maintaining clarity of message",
      "Connect specific points to broader themes"
    ],
    'low-context': [
      "Be explicit and specific about key points",
      "Provide clear, direct explanations with minimal assumption of background knowledge",
      "Focus on observable facts and tangible benefits"
    ]
  };
  
  return examples[level] || examples['medium-context'];
}

/**
 * Generate examples for example style adaptation
 * 
 * @param {string} style - The target example style
 * @returns {Array} Example adaptations
 */
function getExampleStyleExamples(style) {
  const examples = {
    'narrative': [
      "Use story-based examples that follow a clear arc",
      "Include relatable characters and situations",
      "Incorporate emotional elements in your examples"
    ],
    'case-study': [
      "Present examples as formal case studies with measurable outcomes",
      "Include specific company or industry contexts",
      "Structure examples with challenge, solution, and results sections"
    ],
    'analytical': [
      "Base examples on data and research findings",
      "Include specific metrics and measurements",
      "Present multiple perspectives or alternatives"
    ],
    'principle-based': [
      "Connect examples to universal principles or concepts",
      "Focus on the philosophical underpinnings of ideas",
      "Present examples as illustrations of broader truths"
    ],
    'mixed': [
      "Combine narrative elements with data-driven insights",
      "Balance case studies with more personal story examples",
      "Vary example types based on the specific point being made"
    ]
  };
  
  return examples[style] || examples['mixed'];
}

/**
 * Generate examples for value emphasis adaptation
 * 
 * @param {Array} values - The target values to emphasize
 * @returns {Array} Example adaptations
 */
function getValueEmphasisExamples(values) {
  const valueExamples = {
    'innovation': [
      "Highlight the novel aspects of your approach",
      "Emphasize how your solution breaks new ground"
    ],
    'quality': [
      "Focus on the excellence and premium nature of your offering",
      "Emphasize reliability and superior performance"
    ],
    'efficiency': [
      "Highlight time and resource savings",
      "Focus on optimized processes and streamlined operations"
    ],
    'tradition': [
      "Connect your offering to established practices",
      "Emphasize heritage and time-tested approaches"
    ],
    'family': [
      "Highlight benefits for family units",
      "Show how your solution supports family values"
    ],
    'community': [
      "Emphasize collective benefits and shared progress",
      "Focus on how your solution brings people together"
    ],
    'progress': [
      "Highlight advancement and improvement over time",
      "Focus on future-oriented benefits and growth potential"
    ],
    'harmony': [
      "Emphasize balance and peaceful integration",
      "Show how your solution creates unity and equilibrium"
    ],
    'expertise': [
      "Highlight specialized knowledge and professional mastery",
      "Focus on the skilled craftsmanship or deep specialization"
    ],
    'inclusion': [
      "Emphasize how your solution serves diverse audiences",
      "Focus on accessibility and representation for all"
    ]
  };
  
  return values.map(value => valueExamples[value] ? valueExamples[value][0] : `Emphasize ${value} in your content`);
}

/**
 * Generate adaptation prompt for OpenAI
 * 
 * @param {Object} contentElements - The content elements to adapt
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} targetLanguage - The target language
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {string} The prompt for OpenAI
 */
function generateAdaptationPrompt(contentElements, adaptationModel, targetLanguage, adaptationLevel) {
  const adaptationLevelDescriptions = {
    'low': "Make subtle adjustments to better align with the target culture while preserving most of the original content",
    'medium': "Make moderate adjustments to align with the target culture while maintaining the core message",
    'high': "Make significant adjustments to fully align with the target culture's preferences and values"
  };
  
  return `
You are a cultural adaptation expert specializing in optimizing content for different global regions.

Please adapt the following content for the ${adaptationModel.communicationStyle} communication style preferred in this region. The target audience values ${adaptationModel.valueEmphasis.join(', ')}.

Adaptation level: ${adaptationLevel} - ${adaptationLevelDescriptions[adaptationLevel]}

CONTENT TO ADAPT:

Title: ${contentElements.title}

Description: ${contentElements.description}

Body Content: ${contentElements.bodyContent.substring(0, 500)}...

Images: ${JSON.stringify(contentElements.images)}

Examples: ${JSON.stringify(contentElements.examples)}

Calls to Action: ${JSON.stringify(contentElements.callsToAction)}

TARGET ADAPTATION MODEL:
- Communication Style: ${adaptationModel.communicationStyle}
- Image Preferences: ${adaptationModel.imagePreferences}
- Context Level: ${adaptationModel.contextLevel}
- Example Style: ${adaptationModel.exampleStyle}
- Value Emphasis: ${adaptationModel.valueEmphasis.join(', ')}
${targetLanguage ? `- Target Language: ${targetLanguage}` : ''}

Please provide adaptations for each element in the following JSON format:
{
  "title": "Adapted title",
  "description": "Adapted description",
  "bodyContentNotes": ["Note 1", "Note 2", "Note 3"],
  "images": ["Image suggestion 1", "Image suggestion 2"],
  "examples": ["Adapted example 1", "Adapted example 2"],
  "callsToAction": ["Adapted CTA 1", "Adapted CTA 2"]
}
`;
}

/**
 * Parse adapted content from OpenAI response
 * 
 * @param {string} responseText - The response text from OpenAI
 * @returns {Object} Parsed adapted content
 */
function parseAdaptedContent(responseText) {
  try {
    // Extract JSON from response (it might be surrounded by text)
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    // Fallback: try to parse structured response
    const adaptedElements = {};
    
    // Extract title
    const titleMatch = responseText.match(/Title:?\s*(.*?)(?:\n|$)/i);
    if (titleMatch) {
      adaptedElements.title = titleMatch[1].trim();
    }
    
    // Extract description
    const descriptionMatch = responseText.match(/Description:?\s*(.*?)(?:\n\n|\n[A-Z]|$)/is);
    if (descriptionMatch) {
      adaptedElements.description = descriptionMatch[1].trim();
    }
    
    // Extract body content notes
    const bodyContentSection = responseText.match(/Body Content:?\s*(.*?)(?:\n\n|\n[A-Z]|$)/is);
    if (bodyContentSection) {
      adaptedElements.bodyContentNotes = bodyContentSection[1]
        .split('\n')
        .filter(line => line.trim())
        .map(line => line.trim());
    }
    
    return adaptedElements;
  } catch (error) {
    console.error('Error parsing adaptation response:', error);
    return {};
  }
}

/**
 * Generate rule-based adaptation when AI is unavailable
 * 
 * @param {Object} contentElements - The content elements to adapt
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {Object} Adapted content elements
 */
function generateRuleBasedAdaptation(contentElements, adaptationModel, adaptationLevel) {
  return {
    title: generateCulturallyAdaptedTitle(contentElements.title, adaptationModel, adaptationLevel),
    description: generateCulturallyAdaptedDescription(contentElements.description, adaptationModel, adaptationLevel),
    bodyContentNotes: generateBodyContentAdaptationNotes(contentElements.bodyContent, adaptationModel, adaptationLevel),
    images: contentElements.images.map(image => 
      generateCulturallyAdaptedImageSuggestion(image, adaptationModel, adaptationLevel)
    ),
    examples: contentElements.examples.map(example => 
      generateCulturallyAdaptedExample(example, adaptationModel, adaptationLevel)
    ),
    callsToAction: contentElements.callsToAction.map(cta => 
      generateCulturallyAdaptedCTA(cta, adaptationModel, adaptationLevel)
    )
  };
}

/**
 * Generate culturally adapted title
 * 
 * @param {string} title - The original title
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {string} Adaptation suggestion
 */
function generateCulturallyAdaptedTitle(title, adaptationModel, adaptationLevel) {
  // Simple rule-based adaptation
  const communicationStyle = adaptationModel.communicationStyle;
  const primaryValue = adaptationModel.valueEmphasis[0];
  const secondaryValue = adaptationModel.valueEmphasis[1];
  
  let suggestion = `Suggested adaptation: `;
  
  if (communicationStyle === 'relationship-focused') {
    suggestion += `Make the title more collaborative, emphasizing "we" and "together" aspects.`;
  } else if (communicationStyle === 'direct-formal') {
    suggestion += `Make the title more concise and outcome-focused.`;
  } else if (communicationStyle === 'indirect-harmonious') {
    suggestion += `Make the title more balanced and harmony-oriented.`;
  } else {
    suggestion += `Keep title concise while emphasizing ${primaryValue} and ${secondaryValue}.`;
  }
  
  return suggestion;
}

/**
 * Generate culturally adapted description
 * 
 * @param {string} description - The original description
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {string} Adaptation suggestion
 */
function generateCulturallyAdaptedDescription(description, adaptationModel, adaptationLevel) {
  // Simple rule-based adaptation
  const communicationStyle = adaptationModel.communicationStyle;
  const contextLevel = adaptationModel.contextLevel;
  const primaryValue = adaptationModel.valueEmphasis[0];
  
  let suggestion = `Suggested adaptation: `;
  
  if (communicationStyle === 'relationship-focused') {
    suggestion += `Adjust description to emphasize relationship and community aspects.`;
  } else if (communicationStyle === 'direct-formal') {
    suggestion += `Make the description more direct and concise with clear benefits.`;
  } else if (communicationStyle === 'indirect-harmonious') {
    suggestion += `Make the description more balanced with emphasis on harmony and context.`;
  } else {
    suggestion += `Adjust description to use ${communicationStyle} style and highlight ${primaryValue}.`;
  }
  
  if (contextLevel === 'high-context') {
    suggestion += ` Add more contextual background information.`;
  } else if (contextLevel === 'low-context') {
    suggestion += ` Focus on explicit, clear information with minimal assumptions.`;
  }
  
  return suggestion;
}

/**
 * Generate culturally adapted image suggestion
 * 
 * @param {Object|string} image - The original image
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {string} Adaptation suggestion
 */
function generateCulturallyAdaptedImageSuggestion(image, adaptationModel, adaptationLevel) {
  const imageStyle = adaptationModel.imagePreferences;
  
  const styleDescriptions = {
    'vibrant-colors': 'bright, energetic colors with high contrast',
    'subdued-professional': 'professional, corporate aesthetic with subtle colors',
    'balanced-elegant': 'balanced composition with elegant, harmonious elements',
    'colorful-community': 'colorful imagery showing group/community interactions',
    'clean-professional': 'clean, minimal design with professional setting',
    'inclusive-diverse': 'diverse representation with inclusive imagery'
  };
  
  return `Select images with ${styleDescriptions[imageStyle] || imageStyle} characteristics`;
}

/**
 * Generate culturally adapted example
 * 
 * @param {string} example - The original example
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {string} Adaptation suggestion
 */
function generateCulturallyAdaptedExample(example, adaptationModel, adaptationLevel) {
  const exampleStyle = adaptationModel.exampleStyle;
  
  const styleApproaches = {
    'narrative': 'story-based approach with emotional elements',
    'case-study': 'structured case study with challenge-solution-results format',
    'analytical': 'data-driven approach with metrics and research backing',
    'principle-based': 'approach connecting to broader principles and philosophies',
    'mixed': 'balanced approach combining narrative with data elements'
  };
  
  return `Reframe example using ${styleApproaches[exampleStyle] || exampleStyle}`;
}

/**
 * Generate culturally adapted CTA
 * 
 * @param {string} cta - The original CTA
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {string} Adaptation suggestion
 */
function generateCulturallyAdaptedCTA(cta, adaptationModel, adaptationLevel) {
  const communicationStyle = adaptationModel.communicationStyle;
  const primaryValue = adaptationModel.valueEmphasis[0];
  
  const styleApproaches = {
    'relationship-focused': 'collaborative, "we" focused language',
    'direct-formal': 'clear, action-oriented directives',
    'indirect-harmonious': 'gentle suggestions that promote harmony',
    'direct-yet-polite': 'polite but clear directives',
    'expressive-relationship': 'enthusiastic, relationship-building language',
    'balanced': 'balanced approach with clear action and relationship elements'
  };
  
  return `Adjust CTA to align with ${primaryValue} and use ${styleApproaches[communicationStyle] || communicationStyle} tone`;
}

/**
 * Generate body content adaptation notes
 * 
 * @param {string} content - The original body content
 * @param {Object} adaptationModel - The target cultural adaptation model
 * @param {string} adaptationLevel - The level of adaptation
 * @returns {Array} Adaptation notes
 */
function generateBodyContentAdaptationNotes(content, adaptationModel, adaptationLevel) {
  const notes = [
    `Adjust communication style to be more ${adaptationModel.communicationStyle}`,
    `Provide ${adaptationModel.contextLevel === 'high-context' ? 'more' : 'less'} contextual information`,
    `Highlight values like ${adaptationModel.valueEmphasis.join(', ')}`,
    `Use ${adaptationModel.exampleStyle} examples to illustrate points`
  ];
  
  // Add adaptation level-specific notes
  if (adaptationLevel === 'high') {
    notes.push('Make significant structural changes to align with cultural preferences');
    notes.push('Consider completely reframing the narrative for this audience');
  } else if (adaptationLevel === 'medium') {
    notes.push('Adjust key sections while maintaining core message');
    notes.push('Rewrite approximately 50% of content for cultural alignment');
  } else {
    notes.push('Make minimal structural changes, focusing on tone and emphasis');
    notes.push('Keep most content intact with subtle cultural adjustments');
  }
  
  return notes;
}

// =====================================================
// NFT MANAGEMENT FOR AGENT PROMOTION
// =====================================================

/**
 * Setup Express app for the NFT API
 */
const nftApp = express();
nftApp.use(cors({ origin: true }));
nftApp.use(express.json());

/**
 * Authentication middleware for NFT functions
 */
const authenticateNftUser = async (req, res, next) => {
  try {
    // Get authorization header
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ 
        error: 'Unauthorized', 
        message: 'Authentication required' 
      });
    }
    
    // Verify token
    const idToken = authHeader.split('Bearer ')[1];
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    
    // Attach user to request
    req.user = decodedToken;
    next();
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ 
      error: 'Unauthorized', 
      message: 'Invalid authentication token' 
    });
  }
};

/**
 * Create NFT for an agent
 * 
 * @route POST /api/nft/agents/:agentId
 * @param {string} req.params.agentId - The agent ID
 * @param {string} [req.body.title] - Custom NFT title
 * @param {string} [req.body.description] - Custom NFT description
 * @param {Array} [req.body.attributes] - Custom NFT attributes
 * @returns {Object} Created NFT information
 */
nftApp.post('/api/nft/agents/:agentId', authenticateNftUser, async (req, res) => {
  try {
    const { agentId } = req.params;
    const { title, description, attributes, regionLocalization } = req.body;
    
    // Get agent data
    const agentRef = db.collection('agentProfiles').doc(agentId);
    const agentDoc = await agentRef.get();
    
    if (!agentDoc.exists) {
      return res.status(404).json({ 
        error: 'Not Found', 
        message: 'Agent not found' 
      });
    }
    
    const agent = agentDoc.data();
    
    // Apply regional localization if specified
    let regionalizedAgent = { ...agent };
    if (regionLocalization) {
      regionalizedAgent = await localizeAgentForRegion(agent, regionLocalization);
    }
    
    // Generate NFT metadata
    const metadata = {
      name: title || `${regionalizedAgent.name} - 2100 AI Agent`,
      description: description || regionalizedAgent.description,
      image: regionalizedAgent.imageUrl,
      external_url: `https://2100.team/agents/${agentId}`,
      attributes: attributes || [
        {
          trait_type: 'Role',
          value: regionalizedAgent.role
        },
        {
          trait_type: 'Specialty',
          value: regionalizedAgent.specialty
        },
        ...regionalizedAgent.capabilities.map(capability => ({
          trait_type: 'Capability',
          value: capability
        }))
      ]
    };
    
    // Add regional trait if localized
    if (regionLocalization) {
      metadata.attributes.push({
        trait_type: 'Region',
        value: regionLocalization
      });
    }
    
    // Upload to IPFS via NFT.Storage
    const imageResponse = await fetch(regionalizedAgent.imageUrl);
    const imageBlob = await imageResponse.blob();
    const imageFile = new File([imageBlob], `${agentId}.png`, { type: 'image/png' });
    
    const nftResult = await nftStorage.store({
      name: metadata.name,
      description: metadata.description,
      image: imageFile,
      attributes: metadata.attributes
    });
    
    // Load wallet and contract
    const nftContractAddress = functions.config().nft.contract_address;
    const nftContractAbi = require('./abis/AgentNFT.json');
    const nftContract = new web3.eth.Contract(nftContractAbi, nftContractAddress);
    
    const wallet = web3.eth.accounts.wallet.add(functions.config().web3.private_key);
    
    // Create NFT token
    const nftTx = await nftContract.methods.mintAgentNFT(
      req.user.uid,
      nftResult.url,
      web3.utils.asciiToHex(agentId)
    ).send({
      from: wallet.address,
      gas: 500000
    });
    
    // Store NFT data in Firestore
    const nftData = {
      agentId,
      tokenId: nftTx.events.Transfer.returnValues.tokenId,
      owner: req.user.uid,
      metadata: metadata,
      ipfsUrl: nftResult.url,
      transactionHash: nftTx.transactionHash,
      blockNumber: nftTx.blockNumber,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      regionLocalization: regionLocalization || null
    };
    
    const nftRef = await db.collection('agentNFTs').add(nftData);
    
    res.status(201).json({
      id: nftRef.id,
      ...nftData,
      createdAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error creating agent NFT:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Get all NFTs for an agent
 * 
 * @route GET /api/nft/agents/:agentId
 * @param {string} req.params.agentId - The agent ID
 * @returns {Array} Agent NFTs
 */
nftApp.get('/api/nft/agents/:agentId', async (req, res) => {
  try {
    const { agentId } = req.params;
    
    const nftsSnapshot = await db.collection('agentNFTs')
      .where('agentId', '==', agentId)
      .orderBy('createdAt', 'desc')
      .get();
    
    const nfts = nftsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate?.() || null
    }));
    
    res.json(nfts);
  } catch (error) {
    console.error('Error fetching agent NFTs:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Get NFT by ID
 * 
 * @route GET /api/nft/:nftId
 * @param {string} req.params.nftId - The NFT ID
 * @returns {Object} NFT information
 */
nftApp.get('/api/nft/:nftId', async (req, res) => {
  try {
    const { nftId } = req.params;
    
    const nftRef = db.collection('agentNFTs').doc(nftId);
    const nftDoc = await nftRef.get();
    
    if (!nftDoc.exists) {
      return res.status(404).json({ 
        error: 'Not Found', 
        message: 'NFT not found' 
      });
    }
    
    const nftData = nftDoc.data();
    
    res.json({
      id: nftDoc.id,
      ...nftData,
      createdAt: nftData.createdAt?.toDate?.() || null
    });
  } catch (error) {
    console.error('Error fetching NFT:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Transfer NFT to another owner
 * 
 * @route POST /api/nft/:nftId/transfer
 * @param {string} req.params.nftId - The NFT ID
 * @param {string} req.body.recipientAddress - The recipient's blockchain address
 * @returns {Object} Transfer information
 */
nftApp.post('/api/nft/:nftId/transfer', authenticateNftUser, async (req, res) => {
  try {
    const { nftId } = req.params;
    const/**
 * Cultural Adaptation Module
 * 
 * This module provides comprehensive functionality for cultural adaptation of content,
 * including agent NFTs, mobile app configuration, and community generation.
 * 
 * It integrates with Q4D-Lenz Enterprise and Pinecone for semantic search capabilities
 * to deliver culturally relevant experiences across the 2100 domain ecosystem.
 */

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');
const { PineconeClient } = require('@pinecone-database/pinecone');
const { Configuration, OpenAIApi } = require('openai');
const { NFTStorage, File } = require('nft.storage');
const Web3 = require('web3');

// Initialize services
let db;
let pineconeIndex = null;
let openai = null;
let nftStorage = null;
let web3 = null;

// Application initialization
if (!admin.apps.length) {
  admin.initializeApp();
  db = admin.firestore();
  
  // Initialize OpenAI
  const configuration = new Configuration({
    apiKey: functions.config().openai.key,
  });
  openai = new OpenAIApi(configuration);
  
  // Initialize NFT Storage
  nftStorage = new NFTStorage({ 
    token: functions.config().nftstorage.key 
  });
  
  // Initialize Web3
  web3 = new Web3(new Web3.providers.HttpProvider(functions.config().web3.provider));
}

/**
 * Initialize Pinecone client and get index
 * @returns {Promise<Object>} The Pinecone index
 */
async function getPineconeIndex() {
  if (!pineconeIndex) {
    const pinecone = new PineconeClient();
    await pinecone.init({
      environment: functions.config().pinecone.environment,
      apiKey: functions.config().pinecone.apikey,
    });
    pineconeIndex = pinecone.Index(functions.config().pinecone.index);
  }
  return pineconeIndex;
}

// Cultural adaptation models for different regions
const culturalAdaptationModels = {
  'Mexico': {
    communicationStyle: 'relationship-focused',
    imagePreferences: 'vibrant-colors',
    contextLevel: 'high-context',
    exampleStyle: 'narrative',
    valueEmphasis: ['family', 'community', 'innovation', 'progress']
  },
  'UK': {
    communicationStyle: 'direct-yet-polite',
    imagePreferences: 'subdued-professional',
    contextLevel: 'low-context',
    exampleStyle: 'case-study',
    valueEmphasis: ['efficiency', 'innovation', 'tradition', 'expertise']
  },
  'LATAM': {
    communicationStyle: 'expressive-relationship',
    imagePreferences: 'colorful-community',
    contextLevel: 'high-context',
    exampleStyle: 'story-based',
    valueEmphasis: ['community', 'family', 'progress', 'opportunity']
  },
  'Europe': {
    communicationStyle: 'direct-formal',
    imagePreferences: 'clean-professional',
    contextLevel: 'medium-context',
    exampleStyle: 'analytical',
    valueEmphasis: ['quality', 'expertise', 'efficiency', 'innovation']
  },
  'Asia': {
    communicationStyle: 'indirect-harmonious',
    imagePreferences: 'balanced-elegant',
    contextLevel: 'high-context',
    exampleStyle: 'principle-based',
    valueEmphasis: ['harmony', 'tradition', 'innovation', 'excellence']
  },
  'Global': {
    communicationStyle: 'balanced',
    imagePreferences: 'inclusive-diverse',
    contextLevel: 'medium-context',
    exampleStyle: 'mixed',
    valueEmphasis: ['innovation', 'quality', 'inclusion', 'progress']
  }
};

/**
 * Setup Express app for the Cultural Adaptation API
 */
const app = express();
app.use(cors({ origin: true }));
app.use(express.json());

/**
 * Middleware for request logging
 */
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

/**
 * Middleware for error handling
 */
app.use((err, req, res, next) => {
  console.error('API Error:', err);
  res.status(500).json({ 
    error: 'Internal server error', 
    message: err.message 
  });
});

/**
 * Cultural adaptation API for analyzing content against regional preferences
 * 
 * @route POST /api/cultural-adaptation/analyze
 * @param {Object} req.body.content - The content to analyze
 * @param {string} req.body.targetRegion - The target region for adaptation
 * @param {string} [req.body.targetLanguage] - The target language (optional)
 * @returns {Object} Analysis results with scores and recommendations
 */
app.post('/api/cultural-adaptation/analyze', async (req, res) => {
  try {
    const { content, targetRegion, targetLanguage } = req.body;
    
    if (!content || !targetRegion) {
      return res.status(400).json({ 
        error: 'Bad Request', 
        message: 'Content and target region are required' 
      });
    }
    
    // Get cultural adaptation model
    const adaptationModel = culturalAdaptationModels[targetRegion] || culturalAdaptationModels['Global'];
    
    // Analyze content for cultural fit
    const analysis = await analyzeCulturalFit(content, adaptationModel, targetLanguage);
    
    // Log analysis for monitoring
    await db.collection('culturalAnalysisLogs').add({
      targetRegion,
      targetLanguage,
      contentType: content.type || 'unknown',
      overallScore: analysis.overallFitScore,
      fitLevel: analysis.fitLevel,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
    
    res.json(analysis);
  } catch (error) {
    console.error('Error analyzing cultural fit:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Cultural adaptation API for adapting content to regional preferences
 * 
 * @route POST /api/cultural-adaptation/adapt
 * @param {Object} req.body.content - The content to adapt
 * @param {string} req.body.targetRegion - The target region for adaptation
 * @param {string} [req.body.targetLanguage] - The target language (optional)
 * @param {string} [req.body.adaptationLevel=medium] - Adaptation level (low, medium, high)
 * @returns {Object} Adapted content with regional optimizations
 */
app.post('/api/cultural-adaptation/adapt', async (req, res) => {
  try {
    const { content, targetRegion, targetLanguage, adaptationLevel = 'medium' } = req.body;
    
    if (!content || !targetRegion) {
      return res.status(400).json({ 
        error: 'Bad Request', 
        message: 'Content and target region are required' 
      });
    }
    
    // Get cultural adaptation model
    const adaptationModel = culturalAdaptationModels[targetRegion] || culturalAdaptationModels['Global'];
    
    // Validate adaptation level
    const validLevels = ['low', 'medium', 'high'];
    if (!validLevels.includes(adaptationLevel)) {
      return res.status(400).json({
        error: 'Bad Request',
        message: 'Adaptation level must be low, medium, or high'
      });
    }
    
    // Adapt content for cultural fit
    const adaptedContent = await adaptContentForCulture(content, adaptationModel, targetLanguage, adaptationLevel);
    
    // Store the adaptation in Firestore for reference
    const adaptationRef = await db.collection('contentAdaptations').add({
      originalContent: { id: content.id },
      targetRegion,
      targetLanguage,
      adaptationLevel,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Add reference ID to response
    adaptedContent.adaptationId = adaptationRef.id;
    
    res.json(adaptedContent);
  } catch (error) {
    console.error('Error adapting content for culture:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Check cultural fit of one piece of content in multiple regions
 * 
 * @route POST /api/cultural-adaptation/multi-region-analysis
 * @param {Object} req.body.content - The content to analyze
 * @param {Array<string>} req.body.regions - Array of regions to analyze for
 * @returns {Object} Analysis results for each region
 */
app.post('/api/cultural-adaptation/multi-region-analysis', async (req, res) => {
  try {
    const { content, regions } = req.body;
    
    if (!content || !regions || !Array.isArray(regions) || regions.length === 0) {
      return res.status(400).json({ 
        error: 'Bad Request', 
        message: 'Content and at least one region are required' 
      });
    }
    
    // Analyze for each region
    const results = {};
    
    for (const region of regions) {
      const adaptationModel = culturalAdaptationModels[region] || culturalAdaptationModels['Global'];
      results[region] = await analyzeCulturalFit(content, adaptationModel);
    }
    
    // Sort regions by score
    const rankedRegions = Object.entries(results)
      .map(([region, analysis]) => ({
        region,
        score: analysis.overallFitScore,
        fitLevel: analysis.fitLevel
      }))
      .sort((a, b) => b.score - a.score);
    
    res.json({
      content: { id: content.id, type: content.type },
      rankedRegions,
      detailedResults: results
    });
  } catch (error) {
    console.error('Error performing multi-region analysis:', error);
    res.status(500).json({ 
      error: 'Internal Server Error', 
      message: error.message 
    });
  }
});

/**
 * Helper function to analyze content for cultural fit
 * 
 * @param {Object} content - The content to analyze
 * @param {Object} adaptationModel - The cultural adaptation model to use
 * @param {string} [targetLanguage] - Optional target language
 * @returns {Object} Analysis results
 */
async function analyzeCulturalFit(content, adaptationModel, targetLanguage) {
  // Extract content elements
  const { title, description, bodyContent, images, examples, callsToAction } = extractContentElements(content);
  
  // Analyze communication style
  const communicationStyle = analyzeContentCommunicationStyle(bodyContent);
  const communicationStyleFit = calculateStyleFit(communicationStyle, adaptationModel.communicationStyle);
  
  // Analyze image style
  const imageStyle = analyzeImageStyle(images);
  const imageStyleFit = calculateStyleFit(imageStyle, adaptationModel.imagePreferences);
  
  // Analyze context level
  const contextLevel = analyzeContextLevel(bodyContent);
  const contextLevelFit = calculateStyleFit(contextLevel, adaptationModel.contextLevel);
  
  // Analyze example style
  const exampleStyle = analyzeExampleStyle(examples);
  const exampleStyleFit = calculateStyleFit(exampleStyle, adaptationModel.exampleStyle);
  
  // Analyze value alignment
  const valueEmphasis = analyzeValueEmphasis(bodyContent);
  const valueAlignmentScore = calculateValueAlignmentScore(valueEmphasis, adaptationModel.valueEmphasis);
  
  // Calculate overall cultural fit score
  const overallFitScore = parseFloat((
    communicationStyleFit.score * 0.25 +
    imageStyleFit.score * 0.2 +
    contextLevelFit.score * 0.2 +
    exampleStyleFit.score * 0.15 +
    valueAlignmentScore * 0.2
  ).toFixed(2));
  
  // Generate recommendations based on analysis
  const recommendations = generateCulturalAdaptationRecommendations(
    overallFitScore,
    {
      communicationStyle: communicationStyleFit,
      imageStyle: imageStyleFit,
      contextLevel: contextLevelFit,
      exampleStyle: exampleStyleFit,
      valueAlignment: {
        score: valueAlignmentScore,
        currentEmphasis: valueEmphasis,
        targetEmphasis: adaptationModel.valueEmphasis
      }
    },
    adaptationModel,
    content.targetRegion
  );
  
  return {
    overallFitScore,
    fitLevel: getFitLevel(overallFitScore),
    targetRegion: content.targetRegion,
    targetLanguage: targetLanguage || 'en',
    dimensionalAnalysis: {
      communicationStyle: communicationStyleFit,
      imageStyle: imageStyleFit,
      contextLevel: contextLevelFit,
      exampleStyle: exampleStyleFit,
      valueAlignment: {
        score: valueAlignmentScore,
        currentEmphasis: valueEmphasis,
        targetEmphasis: adaptationModel.valueEmphasis
      }
    },
    recommendedImprovements: recommendations
  };
}

/**
 * Helper function to adapt content for cultural fit
 * 
 * @param {Object} content - The content to adapt
 * @param {Object} adaptationModel - The cultural adaptation model to use
 * @param {string} [targetLanguage] - Optional target language
 * @param {string} adaptationLevel - The level of adaptation to apply (low, medium, high)
 * @returns {Object} Adaptation suggestions
 */
async function adaptContentForCulture(content, adaptationModel, targetLanguage, adaptationLevel) {
  // Extract content elements
  const contentElements = extractContentElements(content);
  
  // Apply semantic adaptation using OpenAI
  const adaptationPrompt = generateAdaptationPrompt(
    contentElements, 
    adaptationModel, 
    targetLanguage, 
    adaptationLevel
  );
  
  let adaptedElements;
  
  try {
    // Use OpenAI to generate adapted content
    const response = await openai.createCompletion({
      model: "text-davinci-003",
      prompt: adaptationPrompt,
      max_tokens: 2000,
      temperature: 0.7,
    });
    
    // Parse the adapted content from the OpenAI response
    adaptedElements = parseAdaptedContent(response.data.choices[0].text);
  } catch (error) {
    console.error('Error using OpenAI for adaptation:', error);
    // Fallback to rule-based adaptation if AI fails
    adaptedElements = generateRuleBasedAdaptation(contentElements, adaptationModel, adaptationLevel);
  }
  
  // Create adaptation suggestions
  const suggestions = {
    title: {
      original: contentElements.title,
      suggested: adaptedElements.title || generateCulturallyAdaptedTitle(contentElements.title, adaptationModel, adaptationLevel)
    },
    description: {
      original: contentElements.description,
      suggested: adaptedElements.description || generateCulturallyAdaptedDescription(contentElements.description, adaptationModel, adaptationLevel)
    },
    images: contentElements.images.map((image, index) => ({
      original: image,
      suggestions: adaptedElements.images?.[index] || generateCulturallyAdaptedImageSuggestion(image, adaptationModel, adaptationLevel)
    })),
    examples: contentElements.examples.map((example, index) => ({
      original: example,
      suggested: adaptedElements.examples?.[index] || generateCulturallyAdaptedExample(example, adaptationModel, adaptationLevel)
    })),
    callsToAction: contentElements.callsToAction.map((cta, index) => ({
      original: cta,
      suggested: adaptedElements.callsToAction?.[index] || generateCulturallyAdaptedCTA(cta, adaptationModel, adaptationLevel)
    })),
    bodyContent: {
      original: contentElements.bodyContent,
      adaptationNotes: adaptedElements.bodyContentNotes || generateBodyContentAdaptationNotes(contentElements.bodyContent, adaptationModel, adaptationLevel)
    }
  };
  
  return {
    targetRegion: content.targetRegion,
    targetLanguage: targetLanguage || 'en',
    adaptationLevel,
    suggestions,
    model: adaptationModel
  };
}

/**
 * Extract content elements from a structured content object
 * 
 * @param {Object} content - The content to extract elements from
 * @returns {Object} Extracted content elements
 */
function extractContentElements(content) {
  return {
    title: content.title || '',
    description: content.description || '',
    bodyContent: content.bodyContent || content.html || '',
    images: content.images || [],
    examples: content.examples || [],
    callsToAction: content.callsToAction || []
  };
}

/**
 * Analyze communication style of content
 * 
 * @param {string} content - The content to analyze
 * @returns {string} The identified communication style
 */
function analyzeContentCommunicationStyle(content) {
  // In production, this would use NLP for analysis
  // Simplified implementation for demonstration
  
  // Count specific style markers
  const directWords = ['clearly', 'directly', 'specifically', 'must', 'should', 'always', 'never'];
  const indirectWords = ['perhaps', 'maybe', 'consider', 'possibly', 'might', 'could', 'suggest'];
  const relationshipWords = ['together', 'we', 'us', 'our', 'relationship', 'community', 'team'];
  
  let directCount = 0;
  let indirectCount = 0;
  let relationshipCount = 0;
  
  const contentLower = content.toLowerCase();
  
  // Count occurrences of style markers
  directWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = contentLower.match(regex);
    if (matches) directCount += matches.length;
  });
  
  indirectWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = contentLower.match(regex);
    if (matches) indirectCount += matches.length;
  });
  
  relationshipWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = contentLower.match(regex);
    if (matches) relationshipCount += matches.length;
  });
  
  // Determine dominant style
  if (directCount > indirectCount && directCount > relationshipCount) {
    return 'direct-formal';
  } else if (indirectCount > directCount && indirectCount > relationshipCount) {
    return 'indirect-harmonious';
  } else if (relationshipCount > directCount && relationshipCount > indirectCount) {
    return 'relationship-focused';
  } else {
    return 'balanced';
  }
}

/**
 * Calculate style fit between current and target styles
 * 
 * @param {string} currentStyle - The current style
 * @param {string} targetStyle - The target style
 * @returns {Object} Style fit information
 */
function calculateStyleFit(currentStyle, targetStyle) {
  if (currentStyle === targetStyle) {
    return { score: 1.0, currentStyle, targetStyle, level: 'excellent' };
  } else if (
    (currentStyle === 'balanced') ||
    (targetStyle === 'balanced')
  ) {
    return { score: 0.7, currentStyle, targetStyle, level: 'good' };
  } else {
    // Map related styles to partial matches
    const styleRelationships = {
      'direct-formal': { 'direct-yet-polite': 0.8 },
      'direct-yet-polite': { 'direct-formal': 0.8 },
      'indirect-harmonious': { 'relationship-focused': 0.6 },
      'relationship-focused': { 'indirect-harmonious': 0.6, 'expressive-relationship': 0.8 },
      'expressive-relationship': { 'relationship-focused': 0.8 }
    };
    
    const relationshipScore = styleRelationships[currentStyle]?.[targetStyle] || 0.4;
    const level = relationshipScore >= 0.7 ? 'moderate' : 'needs-improvement';
    
    return { score: relationshipScore, currentStyle, targetStyle, level };
  }
}

/**
 * Analyze image style based on image metadata or content
 * 
 * @param {Array} images - Array of image objects or URLs
 * @returns {string} The identified image style
 */
function analyzeImageStyle(images) {
  // In production, this would use image analysis
  // Simplified implementation for demonstration
  
  if (!images || images.length === 0) {
    return 'unknown';
  }
  
  // Check for style indicators in image metadata or URLs
  const styleIndicators = {
    'vibrant-colors': ['vibrant', 'colorful', 'bright'],
    'subdued-professional': ['professional', 'corporate', 'business', 'formal'],
    'balanced-elegant': ['elegant', 'balanced', 'harmony', 'zen'],
    'colorful-community': ['community', 'group', 'team', 'colorful'],
    'clean-professional': ['clean', 'minimal', 'simple', 'professional'],
    'inclusive-diverse': ['diverse', 'inclusion', 'multicultural', 'global']
  };
  
  // Count style indicators in image metadata or URLs
  const styleCounts = {};
  
  images.forEach(image => {
    const imageString = typeof image === 'string' ? image : JSON.stringify(image);
    
    Object.entries(styleIndicators).forEach(([style, indicators]) => {
      indicators.forEach(indicator => {
        if (imageString.toLowerCase().includes(indicator)) {
          styleCounts[style] = (styleCounts[style] || 0) + 1;
        }
      });
    });
  });
  
  // Find dominant style
  let dominantStyle = 'inclusive-diverse'; // Default
  let maxCount = 0;
  
  Object.entries(styleCounts).forEach(([style, count]) => {
    if (count > maxCount) {
      maxCount = count;
      dominantStyle = style;
    }
  });
  
  return dominantStyle;
}

/**
 * Analyze context level in content
 * 
 * @param {string} content - The content to analyze
 * @returns {string} The identified context level
 */
function analyzeContextLevel(content) {
  // In production, this would use NLP analysis
  // Simplified implementation for demonstration
  
  // Count explicit vs. implicit communication markers
  const explicitMarkers = ['specifically', 'explicitly', 'clearly', 'directly', 'precisely', 'exactly'];
  const implicitMarkers = ['implicitly', 'indirectly', 'perhaps', 'suggests', 'implies', 'hints'];
  const contextualReferences = ['context', 'situation', 'background', 'environment', 'setting', 'framework'];
  
  let explicitCount = 0;
  let implicitCount = 0;
  let contextualCount = 0;
  
  const contentLower = content.toLowerCase();
  
  // Count occurrences of markers
  explicitMarkers.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = contentLower.match(regex);
    if (matches) explicitCount += matches.length;
  });
  
  implicitMarkers.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = contentLower.match(regex);
    if (matches) implicitCount += matches.length;
  });
  
  contextualReferences.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = contentLower.match(regex);
    if (matches) contextualCount += matches.length;
  });
  
  // Determine context level
  const implicitRatio = implicitCount / (explicitCount + implicitCount + 0.1);
  const contextualFactor = Math.min(contextualCount / 5, 1);
  
  if (implicitRatio > 0.6 || contextualFactor > 0.8) {
    return 'high-context';
  } else if (implicitRatio > 0.3 || contextualFactor > 0.4) {
    return 'medium-context';
  } else {
    return 'low-context';
  }
}

/**
 * Analyze example style in content examples
 * 
 * @param {Array} examples - Array of examples to analyze
 * @returns {string} The identified example style
 */
function analyzeExampleStyle(examples) {
  if (!examples || examples.length === 0) {
    return 'unknown';
  }
  
  // Example style markers
  const narrativeMarkers = ['story', 'once', 'when', 'experience', 'journey'];
  const caseStudyMarkers = ['case', 'study', 'company', 'organization', 'client', 'project'];
  const analyticalMarkers = ['analysis', 'data', 'research', 'statistics', 'evidence', 'study shows'];
  const principleMarkers = ['principle', 'concept', 'philosophy', 'theory', 'framework', 'approach'];
  
  let narrativeCount = 0;
  let caseStudyCount = 0;
  let analyticalCount = 0;
  let principleCount = 0;
  
  // Analyze each example
  examples.forEach(example => {
    const exampleText = typeof example === 'string' ? example : JSON.stringify(example);
    const exampleLower = exampleText.toLowerCase();
    
    narrativeMarkers.forEach(marker => {
      if (exampleLower.includes(marker)) narrativeCount++;
    });
    
    caseStudyMarkers.forEach(marker => {
      if (exampleLower.includes(marker)) caseStudyCount++;
    });
    
    analyticalMarkers.forEach(marker => {
      if (exampleLower.includes(marker)) analyticalCount++;
    });
    
    principleMarkers.forEach(marker => {
      if (exampleLower.includes(marker)) principleCount++;
    });
  });
  
  // Determine dominant style
  const counts = [
    { style: 'narrative', count: narrativeCount },
    { style: 'case-study', count: caseStudyCount },
    { style: 'analytical', count: analyticalCount },
    { style: 'principle-based', count: principleCount }
  ];
  
  counts.sort((a, b) => b.count - a.count);
  
  if (counts[0].count === 0) {
    return 'mixed'; // No clear style detected
  }
  
  if (counts[0].count === counts[1].count) {
    return 'mixed'; // Multiple styles with equal frequency
  }
  
  return counts[0].style;
}

/**
 * Analyze value emphasis in content
 * 
 * @param {string} content - The content to analyze
 * @returns {Array} The identified emphasized values
 */
function analyzeValueEmphasis(content) {
  // In production, this would use semantic analysis
  // Simplified implementation for demonstration
  
  // Value keywords mapping
  const valueKeywords = {
    'innovation': ['innovation', 'innovative', 'new', 'novel', 'cutting-edge', 'pioneer', 'breakthrough'],
    'quality': ['quality', 'excellence', 'premium', 'high-standard', 'superior', 'best-in-class'],
    'efficiency': ['efficiency', 'efficient', 'streamlined', 'optimized', 'productivity', 'time-saving'],
    'tradition': ['tradition', 'traditional', 'heritage', 'legacy', 'established', 'time-tested'],
    'family': ['family', 'families', 'household', 'parental', 'children', 'generations'],
    'community': ['community', 'communal', 'collective', 'society', 'neighborhood', 'together'],
    'progress': ['progress', 'advancement', 'improvement', 'growth', 'development', 'forward'],
    'harmony': ['harmony', 'balance', 'peaceful', 'aligned', 'equilibrium', 'unity'],
    'expertise': ['expertise', 'expert', 'specialized', 'professional', 'skillful', 'mastery'],
    'inclusion': ['inclusion', 'inclusive', 'diversity', 'diverse', 'equality', 'representation']
  };
  
  // Count value keywords in content
  const valueCounts = {};
  const contentLower = content.toLowerCase();
  
  Object.entries(valueKeywords).forEach(([value, keywords]) => {
    valueCounts[value] = 0;
    
    keywords.forEach(keyword => {
      const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
      const matches = contentLower.match(regex);
      if (matches) {
        valueCounts[value] += matches.length;
      }
    });
  });
  
  // Sort values by frequency
  const sortedValues = Object.entries(valueCounts)
    .sort((a, b) => b[1] - a[1])
    .filter(([, count]) => count > 0)
    .map(([value]) => value);
  
  // Return top values (or default if none detected)
  return sortedValues.length > 0 ? sortedValues.slice(0, 4) : ['innovation', 'quality', 'progress'];
}

/**
 * Calculate value alignment score between current and target values
 * 
 * @param {Array} currentValues - The current emphasized values
 * @param {Array} targetValues - The target values for the region
 * @returns {number} Alignment score from 0 to 1
 */
function calculateValueAlignmentScore(currentValues, targetValues) {
  if (!currentValues || !targetValues || currentValues.length === 0 || targetValues.length === 0) {
    return 0.5; // Default neutral score
  }
  
  // Count matching values
  const matches = currentValues.filter(value => targetValues.includes(value)).length;
  
  // Calculate alignment score (weighted by position)
  let alignmentScore = 0;
  let maxPossibleScore = 0;
  
  // Values mentioned earlier are weighted more heavily
  for (let i = 0; i < Math.min(currentValues.length,