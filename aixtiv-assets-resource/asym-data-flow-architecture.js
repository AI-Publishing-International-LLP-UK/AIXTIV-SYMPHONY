/**
 * Data Flow Architecture between Dream Commander and Q4D-Lenz
 *
 * This module implements the data flow between Dream Commander and Q4D-Lenz,
 * with Firestore/Pinecone as the data storage and retrieval layer.
 */

// Firebase Admin SDK setup
const admin = require('firebase-admin');
const functions = require('firebase-functions');

// Initialize Pinecone client for vector search
const { PineconeClient } = require('@pinecone-database/pinecone');
const pinecone = new PineconeClient();

// Initialize the apps if not already initialized
if (!admin.apps.length) {
  admin.initializeApp();
}

// Reference to Firestore database
const db = admin.firestore();

/**
 * Dream Commander Data Service
 * Manages data flow from Dream Commander to Q4D-Lenz and Co-Pilots
 */
class DreamCommanderDataService {
  constructor() {
    this.prompts = db.collection('dreamCommanderPrompts');
    this.ownerSubscribers = db.collection('ownerSubscribers');
    this.activitiesCollection = db.collection('activities');
  }

  /**
   * Store a new prompt generated by Dream Commander
   * @param {Object} prompt - The prompt object
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @returns {Promise<string>} - ID of the stored prompt
   */
  async storePrompt(prompt, ownerSubscriberId) {
    const timestamp = admin.firestore.FieldValue.serverTimestamp();

    const promptData = {
      ...prompt,
      ownerSubscriberId,
      created: timestamp,
      status: 'pending',
      interpreted: false,
      activities: [],
    };

    const docRef = await this.prompts.add(promptData);

    // Update owner-subscriber with latest prompt
    await this.ownerSubscribers.doc(ownerSubscriberId).update({
      lastPromptId: docRef.id,
      lastPromptTimestamp: timestamp,
    });

    // Index the prompt in Pinecone for semantic search
    await this.indexPromptInPinecone(docRef.id, prompt);

    return docRef.id;
  }

  /**
   * Index a prompt in Pinecone for semantic search
   * @param {string} promptId - ID of the prompt
   * @param {Object} prompt - The prompt object
   */
  async indexPromptInPinecone(promptId, prompt) {
    try {
      // Initialize Pinecone if not already initialized
      await pinecone.init({
        apiKey: functions.config().pinecone.apikey,
        environment: functions.config().pinecone.environment,
      });

      // Generate embeddings for the prompt text
      const embeddings = await generateEmbeddings(prompt.text);

      // Get the index
      const index = pinecone.Index(functions.config().pinecone.index);

      // Upsert the vector
      await index.upsert({
        vectors: [
          {
            id: promptId,
            values: embeddings,
            metadata: {
              type: 'prompt',
              ownerSubscriberId: prompt.ownerSubscriberId,
              created: new Date().toISOString(),
              category: prompt.category || 'uncategorized',
            },
          },
        ],
      });

      console.log(`Indexed prompt ${promptId} in Pinecone`);
    } catch (error) {
      console.error('Error indexing prompt in Pinecone:', error);
      // Continue execution even if indexing fails
    }
  }

  /**
   * Get pending prompts for a specific owner-subscriber
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @returns {Promise<Array>} - Array of pending prompts
   */
  async getPendingPrompts(ownerSubscriberId) {
    const snapshot = await this.prompts
      .where('ownerSubscriberId', '==', ownerSubscriberId)
      .where('status', '==', 'pending')
      .orderBy('created', 'desc')
      .limit(10)
      .get();

    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    }));
  }

  /**
   * Mark a prompt as interpreted by a Co-Pilot
   * @param {string} promptId - ID of the prompt
   * @param {string} agentId - ID of the interpreting agent
   * @param {Object} interpretation - The interpretation details
   */
  async markPromptInterpreted(promptId, agentId, interpretation) {
    await this.prompts.doc(promptId).update({
      interpreted: true,
      interpretedBy: agentId,
      interpretedAt: admin.firestore.FieldValue.serverTimestamp(),
      interpretation: interpretation,
    });
  }

  /**
   * Link activities to a prompt
   * @param {string} promptId - ID of the prompt
   * @param {Array} activityIds - Array of activity IDs
   */
  async linkActivitiesToPrompt(promptId, activityIds) {
    await this.prompts.doc(promptId).update({
      activities: admin.firestore.FieldValue.arrayUnion(...activityIds),
      status: 'in_progress',
    });
  }
}

/**
 * Q4D-Lenz Data Service
 * Manages data flow from Q4D-Lenz to Dream Commander and Co-Pilots
 */
class Q4DLenzDataService {
  constructor() {
    this.lenzProfiles = db.collection('q4dLenzProfiles');
    this.interpretations = db.collection('lenzInterpretations');
    this.linkedInData = db.collection('linkedInData');
  }

  /**
   * Store a Q4D-Lenz profile for an agent
   * @param {string} agentId - ID of the agent
   * @param {string} lenzType - Type of the lens (personal, professional, enterprise)
   * @param {Object} profile - The lens profile data
   * @returns {Promise<void>}
   */
  async storeLenzProfile(agentId, lenzType, profile) {
    await this.lenzProfiles.doc(agentId).set(
      {
        agentId,
        lenzType,
        profile,
        created: admin.firestore.FieldValue.serverTimestamp(),
        updated: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );
  }

  /**
   * Get a Q4D-Lenz profile for an agent
   * @param {string} agentId - ID of the agent
   * @returns {Promise<Object>} - The lens profile
   */
  async getLenzProfile(agentId) {
    const doc = await this.lenzProfiles.doc(agentId).get();

    if (!doc.exists) {
      throw new Error(`Q4D-Lenz profile for agent ${agentId} not found`);
    }

    return doc.data();
  }

  /**
   * Store a prompt interpretation from Q4D-Lenz
   * @param {string} promptId - ID of the prompt
   * @param {string} agentId - ID of the interpreting agent
   * @param {Object} interpretation - The interpretation details
   * @returns {Promise<string>} - ID of the stored interpretation
   */
  async storeInterpretation(promptId, agentId, interpretation) {
    const interpretationData = {
      promptId,
      agentId,
      interpretation,
      created: admin.firestore.FieldValue.serverTimestamp(),
      potentialActivities: interpretation.potentialActivities || [],
    };

    const docRef = await this.interpretations.add(interpretationData);

    // Index the interpretation in Pinecone for semantic search
    await this.indexInterpretationInPinecone(docRef.id, interpretationData);

    return docRef.id;
  }

  /**
   * Index an interpretation in Pinecone for semantic search
   * @param {string} interpretationId - ID of the interpretation
   * @param {Object} interpretation - The interpretation data
   */
  async indexInterpretationInPinecone(interpretationId, interpretation) {
    try {
      // Initialize Pinecone if not already initialized
      await pinecone.init({
        apiKey: functions.config().pinecone.apikey,
        environment: functions.config().pinecone.environment,
      });

      // Generate embeddings for the interpretation
      const embeddings = await generateEmbeddings(
        JSON.stringify(interpretation.interpretation)
      );

      // Get the index
      const index = pinecone.Index(functions.config().pinecone.index);

      // Upsert the vector
      await index.upsert({
        vectors: [
          {
            id: interpretationId,
            values: embeddings,
            metadata: {
              type: 'interpretation',
              promptId: interpretation.promptId,
              agentId: interpretation.agentId,
              created: new Date().toISOString(),
            },
          },
        ],
      });

      console.log(`Indexed interpretation ${interpretationId} in Pinecone`);
    } catch (error) {
      console.error('Error indexing interpretation in Pinecone:', error);
      // Continue execution even if indexing fails
    }
  }

  /**
   * Store LinkedIn data from Dr. Match App
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {Object} linkedInData - The LinkedIn data
   * @returns {Promise<void>}
   */
  async storeLinkedInData(ownerSubscriberId, linkedInData) {
    await this.linkedInData.doc(ownerSubscriberId).set(
      {
        ownerSubscriberId,
        linkedInData,
        fetchedAt: admin.firestore.FieldValue.serverTimestamp(),
        processed: false,
      },
      { merge: true }
    );
  }

  /**
   * Get LinkedIn data for an owner-subscriber
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @returns {Promise<Object>} - The LinkedIn data
   */
  async getLinkedInData(ownerSubscriberId) {
    const doc = await this.linkedInData.doc(ownerSubscriberId).get();

    if (!doc.exists) {
      throw new Error(`LinkedIn data for owner ${ownerSubscriberId} not found`);
    }

    return doc.data().linkedInData;
  }
}

/**
 * Co-Pilot Data Service
 * Manages data flow for Co-Pilots
 */
class CoPilotDataService {
  constructor() {
    this.agents = db.collection('agents');
    this.activities = db.collection('activities');
    this.deliverables = db.collection('deliverables');
    this.authorizations = db.collection('authorizations');
    this.feedbacks = db.collection('feedbacks');
  }

  /**
   * Store an agent profile
   * @param {string} agentId - ID of the agent
   * @param {Object} profile - The agent profile
   * @returns {Promise<void>}
   */
  async storeAgentProfile(agentId, profile) {
    await this.agents.doc(agentId).set(
      {
        ...profile,
        updated: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );
  }

  /**
   * Get an agent profile
   * @param {string} agentId - ID of the agent
   * @returns {Promise<Object>} - The agent profile
   */
  async getAgentProfile(agentId) {
    const doc = await this.agents.doc(agentId).get();

    if (!doc.exists) {
      throw new Error(`Agent ${agentId} not found`);
    }

    return doc.data();
  }

  /**
   * Create a new activity for a Co-Pilot
   * @param {Object} activity - The activity details
   * @param {string} agentId - ID of the executing agent
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {string} promptId - ID of the related prompt
   * @returns {Promise<string>} - ID of the created activity
   */
  async createActivity(activity, agentId, ownerSubscriberId, promptId) {
    const activityData = {
      ...activity,
      agentId,
      ownerSubscriberId,
      promptId,
      status: 'planned',
      created: admin.firestore.FieldValue.serverTimestamp(),
      updated: admin.firestore.FieldValue.serverTimestamp(),
      requiresApproval: activity.requiresApproval || false,
      approved: !activity.requiresApproval, // Auto-approve if no approval required
      deliverableId: null,
    };

    const docRef = await this.activities.add(activityData);

    return docRef.id;
  }

  /**
   * Update activity status
   * @param {string} activityId - ID of the activity
   * @param {string} status - New status
   * @param {Object} additionalData - Additional data to update
   * @returns {Promise<void>}
   */
  async updateActivityStatus(activityId, status, additionalData = {}) {
    await this.activities.doc(activityId).update({
      status,
      updated: admin.firestore.FieldValue.serverTimestamp(),
      ...additionalData,
    });
  }

  /**
   * Create a deliverable for an activity
   * @param {string} activityId - ID of the activity
   * @param {Object} deliverable - The deliverable data
   * @returns {Promise<string>} - ID of the created deliverable
   */
  async createDeliverable(activityId, deliverable) {
    const deliverableData = {
      activityId,
      ...deliverable,
      created: admin.firestore.FieldValue.serverTimestamp(),
      status: 'pending_authorization',
      authorized: false,
      authorizationQRCode: await generateQRCode(activityId),
    };

    const docRef = await this.deliverables.add(deliverableData);

    // Update the activity with the deliverable ID
    await this.activities.doc(activityId).update({
      deliverableId: docRef.id,
      status: 'completed',
      updated: admin.firestore.FieldValue.serverTimestamp(),
    });

    return docRef.id;
  }

  /**
   * Process a deliverable authorization
   * @param {string} deliverableId - ID of the deliverable
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {Object} authorizationData - The authorization data
   * @returns {Promise<string>} - ID of the authorization
   */
  async processAuthorization(
    deliverableId,
    ownerSubscriberId,
    authorizationData
  ) {
    // Verify the owner-subscriber is authorized to approve this deliverable
    const deliverable = await this.deliverables.doc(deliverableId).get();

    if (!deliverable.exists) {
      throw new Error(`Deliverable ${deliverableId} not found`);
    }

    const deliverableData = deliverable.data();
    const activity = await this.activities
      .doc(deliverableData.activityId)
      .get();

    if (!activity.exists) {
      throw new Error(`Activity ${deliverableData.activityId} not found`);
    }

    const activityData = activity.data();

    if (activityData.ownerSubscriberId !== ownerSubscriberId) {
      throw new Error('Unauthorized authorization attempt');
    }

    // Create the authorization record
    const authorizationRecord = {
      deliverableId,
      ownerSubscriberId,
      ...authorizationData,
      authorized: true,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      blockchainTransactionId: await recordOnBlockchain('authorization', {
        deliverableId,
        ownerSubscriberId,
      }),
    };

    const docRef = await this.authorizations.add(authorizationRecord);

    // Update the deliverable status
    await this.deliverables.doc(deliverableId).update({
      status: 'authorized',
      authorized: true,
      authorizationId: docRef.id,
      updated: admin.firestore.FieldValue.serverTimestamp(),
    });

    return docRef.id;
  }

  /**
   * Store feedback for a deliverable
   * @param {string} deliverableId - ID of the deliverable
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {Object} feedbackData - The feedback data
   * @returns {Promise<string>} - ID of the created feedback
   */
  async storeFeedback(deliverableId, ownerSubscriberId, feedbackData) {
    const feedback = {
      deliverableId,
      ownerSubscriberId,
      ...feedbackData,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      processed: false,
    };

    const docRef = await this.feedbacks.add(feedback);

    // Update the deliverable with feedback status
    await this.deliverables.doc(deliverableId).update({
      hasFeedback: true,
      feedbackId: docRef.id,
      updated: admin.firestore.FieldValue.serverTimestamp(),
    });

    return docRef.id;
  }
}

/**
 * Blockchain Service
 * Handles blockchain operations for authorization and verification
 */
class BlockchainService {
  constructor() {
    this.transactions = db.collection('blockchainTransactions');
  }

  /**
   * Record a transaction on the blockchain
   * @param {string} type - Transaction type
   * @param {Object} data - Transaction data
   * @returns {Promise<string>} - Transaction ID
   */
  async recordTransaction(type, data) {
    // In a real implementation, this would interact with an actual blockchain
    // For now, we'll simulate by storing in Firestore

    const transaction = {
      type,
      data,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      verified: true,
      hash: await generateTransactionHash(type, data),
    };

    const docRef = await this.transactions.add(transaction);
    return docRef.id;
  }

  /**
   * Verify a QR code for blockchain authorization
   * @param {string} qrData - Data from the QR code
   * @returns {Promise<Object>} - Verification result
   */
  async verifyQRCode(qrData) {
    try {
      // Parse the QR data
      const data = JSON.parse(qrData);

      // Verify the hash
      const calculatedHash = await generateTransactionHash(
        data.type,
        data.data
      );
      const hashMatch = calculatedHash === data.hash;

      return {
        valid: hashMatch,
        data: data.data,
        type: data.type,
        timestamp: data.timestamp,
      };
    } catch (error) {
      console.error('Error verifying QR code:', error);
      return {
        valid: false,
        error: error.message,
      };
    }
  }

  /**
   * Generate a QR code for authorization
   * @param {string} type - Transaction type
   * @param {Object} data - Transaction data
   * @returns {Promise<string>} - QR code data URL
   */
  async generateAuthorizationQR(type, data) {
    const transactionData = {
      type,
      data,
      timestamp: new Date().toISOString(),
      hash: await generateTransactionHash(type, data),
    };

    // Generate QR code (in a real implementation, this would create an actual QR code)
    return JSON.stringify(transactionData);
  }
}

/**
 * Pinecone Vector Database Service
 * Handles vector embeddings and semantic search
 */
class PineconeService {
  constructor() {
    this.initialize();
  }

  /**
   * Initialize the Pinecone client
   */
  async initialize() {
    try {
      await pinecone.init({
        apiKey: functions.config().pinecone.apikey,
        environment: functions.config().pinecone.environment,
      });

      this.index = pinecone.Index(functions.config().pinecone.index);
      console.log('Pinecone initialized successfully');
    } catch (error) {
      console.error('Error initializing Pinecone:', error);
      // Continue without Pinecone if initialization fails
    }
  }

  /**
   * Store a vector in Pinecone
   * @param {string} id - Vector ID
   * @param {Array} vector - Vector embeddings
   * @param {Object} metadata - Vector metadata
   * @returns {Promise<boolean>} - Success status
   */
  async storeVector(id, vector, metadata) {
    try {
      if (!this.index) {
        await this.initialize();
      }

      await this.index.upsert({
        vectors: [
          {
            id,
            values: vector,
            metadata,
          },
        ],
      });

      return true;
    } catch (error) {
      console.error('Error storing vector in Pinecone:', error);
      return false;
    }
  }

  /**
   * Search for similar vectors in Pinecone
   * @param {Array} queryVector - Query vector embeddings
   * @param {Object} filter - Search filter
   * @param {number} topK - Number of results to return
   * @returns {Promise<Array>} - Search results
   */
  async search(queryVector, filter, topK = 10) {
    try {
      if (!this.index) {
        await this.initialize();
      }

      const results = await this.index.query({
        vector: queryVector,
        filter,
        topK,
        includeMetadata: true,
      });

      return results.matches || [];
    } catch (error) {
      console.error('Error searching Pinecone:', error);
      return [];
    }
  }
}

// Import utility functions from the provided utility module
const {
  getDocumentById,
  updateDocument,
  createDocument,
  handleHttpError,
  createHttpError,
  authenticateUser,
  requireAdmin,
  formatTimestamp,
  extractTextFromHtml,
} = require('./utils');

/**
 * Additional utility functions to support data flow
 */

/**
 * Generate embeddings for text using an embedding model
 * @param {string} text - Text to generate embeddings for
 * @returns {Promise<Array>} - Vector embeddings
 */
async function generateEmbeddings(text) {
  try {
    // In a real implementation, this would call an embedding API (OpenAI, Anthropic, etc.)
    // For now, we'll return a placeholder vector
    return Array.from({ length: 1536 }, () => Math.random() * 2 - 1);
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw error;
  }
}

/**
 * Generate a transaction hash for blockchain records
 * @param {string} type - Transaction type
 * @param {Object} data - Transaction data
 * @returns {Promise<string>} - Transaction hash
 */
async function generateTransactionHash(type, data) {
  try {
    // In a real implementation, this would generate a cryptographic hash
    // For now, we'll return a placeholder
    const stringToHash = `${type}-${JSON.stringify(data)}-${new Date().toISOString()}`;
    return Buffer.from(stringToHash).toString('base64');
  } catch (error) {
    console.error('Error generating transaction hash:', error);
    throw error;
  }
}

/**
 * Generate a QR code for authorization
 * @param {string} data - Data to encode in the QR code
 * @returns {Promise<string>} - QR code data URL
 */
async function generateQRCode(data) {
  try {
    // In a real implementation, this would generate an actual QR code
    // For now, we'll return a placeholder
    return `data:image/png;base64,${Buffer.from(data).toString('base64')}`;
  } catch (error) {
    console.error('Error generating QR code:', error);
    throw error;
  }
}

/**
 * Record a transaction on the blockchain
 * @param {string} type - Transaction type
 * @param {Object} data - Transaction data
 * @returns {Promise<string>} - Transaction ID
 */
async function recordOnBlockchain(type, data) {
  const blockchainService = new BlockchainService();
  return blockchainService.recordTransaction(type, data);
}

// Export the data services for use in other modules
module.exports = {
  DreamCommanderDataService,
  Q4DLenzDataService,
  CoPilotDataService,
  BlockchainService,
  PineconeService,

  // Utility functions
  generateEmbeddings,
  generateTransactionHash,
  generateQRCode,
  recordOnBlockchain,
};
