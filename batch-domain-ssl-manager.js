/**
 * Dr. Claude Orchestrator
 * Batch Domain SSL Manager for Aixtiv Symphony
 * 
 * This script handles SSL certificate management for multiple domains,
 * implementing a smart batching system that respects quota limits and
 * provides comprehensive reporting.
 */

const fs = require('fs');
const path = require('path');
const { execSync, exec } = require('child_process');
const util = require('util');

// Convert exec to Promise-based for async/await
const execAsync = util.promisify(exec);

// Configuration
const CONFIG = {
  PROJECT_ID: 'api-for-warp-drive',
  DOMAINS_FILE: path.join(__dirname, 'domains', 'active-domains.txt'),
  OUTPUT_DIR: path.join(__dirname, 'domains', 'dns-records'),
  FIREBASE_BASE_IP: '151.101.1.195',
  BATCH_SIZE: 5,         // Number of domains to process in each batch
  BATCH_DELAY: 3600000,  // Delay between batches (1 hour) to respect quotas
  RETRY_DELAY: 300000,   // Delay before retry (5 minutes)
  MAX_RETRIES: 3,        // Maximum number of retries for failed operations
  VERIFICATION_DELAY: 3600000 // Time to wait for verification (1 hour)
};

// Ensure directories exist
if (!fs.existsSync(path.dirname(CONFIG.DOMAINS_FILE))) {
  fs.mkdirSync(path.dirname(CONFIG.DOMAINS_FILE), { recursive: true });
}
if (!fs.existsSync(CONFIG.OUTPUT_DIR)) {
  fs.mkdirSync(CONFIG.OUTPUT_DIR, { recursive: true });
}

// Utility function for logging
function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  const prefix = {
    info: '[ INFO ]',
    error: '[ERROR ]',
    success: '[  OK  ]',
    warning: '[ WARN ]'
  }[type] || '[ INFO ]';
  
  console.log(`${prefix} ${timestamp} - ${message}`);
}

/**
 * Read domains from file or create sample file if it doesn't exist
 */
function readDomains() {
  if (!fs.existsSync(CONFIG.DOMAINS_FILE)) {
    log(`Domains file not found, creating sample at ${CONFIG.DOMAINS_FILE}`, 'warning');
    const sampleDomains = [
      'asoos.2100.cool',
      'www.asoos.2100.cool',
      'drclaude.live',
      'coaching2100.com',
      'aixtiv.com'
    ];
    fs.writeFileSync(CONFIG.DOMAINS_FILE, sampleDomains.join('\n'));
  }
  
  const domains = fs.readFileSync(CONFIG.DOMAINS_FILE, 'utf8')
    .split('\n')
    .map(d => d.trim())
    .filter(d => d && !d.startsWith('#'));
  
  log(`Loaded ${domains.length} domains from ${CONFIG.DOMAINS_FILE}`);
  return domains;
}

/**
 * Generate site ID from domain
 */
function generateSiteId(domain) {
  return domain.replace(/\./g, '-');
}

/**
 * Generate DNS records for a domain
 */
function generateDnsRecords(domain) {
  const siteId = generateSiteId(domain);
  const baseDomain = domain.split('.').slice(-2).join('.');
  const subdomain = domain.replace(`.${baseDomain}`, '');
  
  const dnsRecords = [
    {
      type: 'A',
      name: subdomain || '@',
      value: CONFIG.FIREBASE_BASE_IP,
      ttl: 3600,
      description: 'Points to Firebase hosting'
    },
    {
      type: 'CNAME',
      name: 'www.' + (subdomain ? `${subdomain}.` : ''),
      value: `${siteId}.web.app`,
      ttl: 3600,
      description: 'www subdomain pointing to Firebase app'
    },
    {
      type: 'TXT',
      name: subdomain ? subdomain : '@',
      value: `google-site-verification=firebase-${siteId}-${Date.now().toString(36)}`,
      ttl: 3600,
      description: 'Google site verification record'
    }
  ];
  
  return dnsRecords;
}

/**
 * Write DNS records to file
 */
function writeDnsRecords(domain, dnsRecords) {
  const outputFile = path.join(CONFIG.OUTPUT_DIR, `${domain}-dns-records.txt`);
  
  let fileContent = `# DNS Records for ${domain}\n`;
  fileContent += '# Generated by Dr. Claude Orchestrator Batch Domain SSL Manager\n';
  fileContent += `# Date: ${new Date().toISOString()}\n\n`;
  
  dnsRecords.forEach(record => {
    fileContent += `# ${record.description}\n`;
    fileContent += `${record.type} ${record.name} ${record.value} ${record.ttl}\n\n`;
  });
  
  fs.writeFileSync(outputFile, fileContent);
  log(`DNS records for ${domain} saved to ${outputFile}`, 'success');
  
  return outputFile;
}

/**
 * Create Firebase hosting site for a domain
 */
async function createFirebaseSite(domain) {
  const siteId = generateSiteId(domain);
  
  try {
    log(`Creating Firebase hosting site for ${domain} (${siteId})`);
    
    // Check if site already exists
    try {
      await execAsync(`firebase hosting:sites:get ${siteId} --project ${CONFIG.PROJECT_ID}`);
      log(`Site ${siteId} already exists, skipping creation`, 'warning');
      return true;
    } catch (error) {
      // Site doesn't exist, proceed with creation
    }
    
    // Create site
    const { stdout, stderr } = await execAsync(
      `firebase hosting:sites:create ${siteId} --project ${CONFIG.PROJECT_ID}`
    );
    
    if (stderr && stderr.includes('Error')) {
      throw new Error(stderr);
    }
    
    log(`Successfully created site ${siteId} for ${domain}`, 'success');
    return true;
  } catch (error) {
    if (error.message.includes('429') || error.message.includes('quota')) {
      log(`Quota limit reached for site creation: ${error.message}`, 'error');
      return { quotaError: true, error };
    }
    
    log(`Failed to create site for ${domain}: ${error.message}`, 'error');
    return false;
  }
}

/**
 * Connect domain to Firebase hosting
 */
async function connectDomainToFirebase(domain) {
  const siteId = generateSiteId(domain);
  
  try {
    log(`Connecting domain ${domain} to Firebase hosting site ${siteId}`);
    
    const { stdout, stderr } = await execAsync(
      `firebase hosting:sites:update ${siteId} --project ${CONFIG.PROJECT_ID} --domains="${domain}"`
    );
    
    if (stderr && stderr.includes('Error')) {
      throw new Error(stderr);
    }
    
    log(`Successfully connected domain ${domain} to site ${siteId}`, 'success');
    return true;
  } catch (error) {
    log(`Failed to connect domain ${domain} to Firebase: ${error.message}`, 'error');
    return false;
  }
}

/**
 * Process a single domain
 */
async function processDomain(domain, retryCount = 0) {
  log(`Processing domain: ${domain}`);
  
  try {
    // Generate DNS records
    const dnsRecords = generateDnsRecords(domain);
    const dnsRecordsFile = writeDnsRecords(domain, dnsRecords);
    
    // Create Firebase site
    const siteCreated = await createFirebaseSite(domain);
    
    if (siteCreated === true) {
      // Connect domain to Firebase
      const domainConnected = await connectDomainToFirebase(domain);
      
      if (domainConnected) {
        log(`Domain ${domain} successfully configured`, 'success');
        return { success: true, domain, dnsRecordsFile };
      }
    } else if (siteCreated && siteCreated.quotaError) {
      log(`Quota limit reached for ${domain}, will retry later`, 'warning');
      return { quotaError: true, domain };
    }
    
    // If we reach here, something failed
    if (retryCount < CONFIG.MAX_RETRIES) {
      log(`Retrying domain ${domain} (Attempt ${retryCount + 1}/${CONFIG.MAX_RETRIES})`, 'warning');
      return new Promise(resolve => {
        setTimeout(() => {
          resolve(processDomain(domain, retryCount + 1));
        }, CONFIG.RETRY_DELAY);
      });
    }
    
    log(`Failed to process domain ${domain} after ${CONFIG.MAX_RETRIES} attempts`, 'error');
    return { success: false, domain, error: 'Max retries exceeded' };
  } catch (error) {
    log(`Error processing domain ${domain}: ${error.message}`, 'error');
    return { success: false, domain, error: error.message };
  }
}

/**
 * Process domains in batches respecting quota limits
 */
async function processDomainsInBatches(domains) {
  log(`Starting batch processing of ${domains.length} domains`);
  
  const results = {
    successful: [],
    failed: [],
    pending: [...domains]
  };
  
  const batches = [];
  for (let i = 0; i < domains.length; i += CONFIG.BATCH_SIZE) {
    batches.push(domains.slice(i, i + CONFIG.BATCH_SIZE));
  }
  
  log(`Created ${batches.length} batches of up to ${CONFIG.BATCH_SIZE} domains each`);
  
  for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
    const batch = batches[batchIndex];
    log(`Processing batch ${batchIndex + 1}/${batches.length} with ${batch.length} domains`);
    
    // Process domains in current batch in parallel
    const batchResults = await Promise.all(batch.map(domain => processDomain(domain)));
    
    // Update results
    batchResults.forEach(result => {
      if (result.success) {
        results.successful.push(result);
        results.pending = results.pending.filter(d => d !== result.domain);
      } else if (result.quotaError) {
        // Keep in pending, will be processed in the next batch cycle
      } else {
        results.failed.push(result);
        results.pending = results.pending.filter(d => d !== result.domain);
      }
    });
    
    // Write interim report
    writeReport(results, true);
    
    // Check if we have any domains left to process
    if (results.pending.length === 0) {
      log('All domains processed, no more pending domains', 'success');
      break;
    }
    
    // Check if we need to wait for quota reset before the next batch
    if (batchIndex < batches.length - 1) {
      const quotaErrorCount = batchResults.filter(r => r.quotaError).length;
      
      if (quotaErrorCount > 0) {
        log(`Encountered ${quotaErrorCount} quota errors, waiting for quota reset`, 'warning');
        log(`Waiting ${CONFIG.BATCH_DELAY / 60000} minutes before processing next batch`, 'info');
        
        await new Promise(resolve => setTimeout(resolve, CONFIG.BATCH_DELAY));
      }
    }
  }
  
  return results;
}

/**
 * Write processing report
 */
function writeReport(results, interim = false) {
  const reportFile = path.join(
    CONFIG.OUTPUT_DIR, 
    `domain-ssl-report${interim ? '-interim' : ''}-${new Date().toISOString().replace(/[:\.]/g, '-')}.json`
  );
  
  const report = {
    timestamp: new Date().toISOString(),
    summary: {
      total: results.successful.length + results.failed.length + results.pending.length,
      successful: results.successful.length,
      failed: results.failed.length,
      pending: results.pending.length
    },
    successful: results.successful,
    failed: results.failed,
    pending: results.pending
  };
  
  fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
  log(`Report ${interim ? '(interim)' : ''} saved to ${reportFile}`);
  
  return reportFile;
}

/**
 * Main function
 */
async function main() {
  try {
    console.log('\n========================================================');
    console.log('      Dr. Claude Orchestrator - Batch Domain SSL Manager');
    console.log('========================================================\n');
    
    // Read domains
    const domains = readDomains();
    
    if (domains.length === 0) {
      log('No domains to process, exiting', 'warning');
      return;
    }
    
    // Process domains in batches
    const results = await processDomainsInBatches(domains);
    
    // Write final report
    const reportFile = writeReport(results);
    
    // Print summary
    console.log('\n========================================================');
    console.log('                        Summary                         ');
    console.log('========================================================');
    console.log(`Total domains:     ${results.successful.length + results.failed.length + results.pending.length}`);
    console.log(`Successful:        ${results.successful.length}`);
    console.log(`Failed:            ${results.failed.length}`);
    console.log(`Pending/Quota:     ${results.pending.length}`);
    console.log(`Report saved to:   ${reportFile}`);
    console.log('\nNext steps:');
    console.log('1. Add the DNS records from the output files to your domain registrar');
    console.log('2. Wait for DNS propagation (may take 24-48 hours)');
    console.log('3. SSL certificates will be automatically provisioned');
    
    if (results.pending.length > 0) {
      console.log('\nTo process remaining domains after quota reset:');
      console.log(`node batch-domain-ssl-manager.js`);
    }
    
    console.log('\n========================================================');
  } catch (error) {
    console.error(`Fatal error: ${error.message}`);
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

// Execute main function
main();