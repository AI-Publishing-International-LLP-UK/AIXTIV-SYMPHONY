/**
 * Data Flow Architecture between Dream Commander and Q4D-Lenz
 * 
 * This module implements the data flow between Dream Commander and Q4D-Lenz,
 * with Firestore/Pinecone as the data storage and retrieval layer.
 */

// Firebase Admin SDK setup
const admin = require('firebase-admin');
const functions = require('firebase-functions');

// Initialize Pinecone client for vector search
const { PineconeClient } = require('@pinecone-database/pinecone');
const pinecone = new PineconeClient();

// Initialize the apps if not already initialized
if (!admin.apps.length) {
  admin.initializeApp();
}

// Reference to Firestore database
const db = admin.firestore();

/**
 * Dream Commander Data Service
 * Manages data flow from Dream Commander to Q4D-Lenz and Co-Pilots
 */
class DreamCommanderDataService {
  constructor() {
    this.prompts = db.collection('dreamCommanderPrompts');
    this.ownerSubscribers = db.collection('ownerSubscribers');
    this.activitiesCollection = db.collection('activities');
  }

  /**
   * Store a new prompt generated by Dream Commander
   * @param {Object} prompt - The prompt object
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @returns {Promise<string>} - ID of the stored prompt
   */
  async storePrompt(prompt, ownerSubscriberId) {
    const timestamp = admin.firestore.FieldValue.serverTimestamp();
    
    const promptData = {
      ...prompt,
      ownerSubscriberId,
      created: timestamp,
      status: 'pending',
      interpreted: false,
      activities: []
    };
    
    const docRef = await this.prompts.add(promptData);
    
    // Update owner-subscriber with latest prompt
    await this.ownerSubscribers.doc(ownerSubscriberId).update({
      lastPromptId: docRef.id,
      lastPromptTimestamp: timestamp
    });
    
    // Index the prompt in Pinecone for semantic search
    await this.indexPromptInPinecone(docRef.id, prompt);
    
    return docRef.id;
  }
  
  /**
   * Index a prompt in Pinecone for semantic search
   * @param {string} promptId - ID of the prompt
   * @param {Object} prompt - The prompt object
   */
  async indexPromptInPinecone(promptId, prompt) {
    try {
      // Initialize Pinecone if not already initialized
      await pinecone.init({
        apiKey: functions.config().pinecone.apikey,
        environment: functions.config().pinecone.environment
      });
      
      // Generate embeddings for the prompt text
      const embeddings = await generateEmbeddings(prompt.text);
      
      // Get the index
      const index = pinecone.Index(functions.config().pinecone.index);
      
      // Upsert the vector
      await index.upsert({
        vectors: [{
          id: promptId,
          values: embeddings,
          metadata: {
            type: 'prompt',
            ownerSubscriberId: prompt.ownerSubscriberId,
            created: new Date().toISOString(),
            category: prompt.category || 'uncategorized'
          }
        }]
      });
      
      console.log(`Indexed prompt ${promptId} in Pinecone`);
    } catch (error) {
      console.error('Error indexing prompt in Pinecone:', error);
      // Continue execution even if indexing fails
    }
  }
  
  /**
   * Get pending prompts for a specific owner-subscriber
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @returns {Promise<Array>} - Array of pending prompts
   */
  async getPendingPrompts(ownerSubscriberId) {
    const snapshot = await this.prompts
      .where('ownerSubscriberId', '==', ownerSubscriberId)
      .where('status', '==', 'pending')
      .orderBy('created', 'desc')
      .limit(10)
      .get();
      
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  }
  
  /**
   * Mark a prompt as interpreted by a Co-Pilot
   * @param {string} promptId - ID of the prompt
   * @param {string} agentId - ID of the interpreting agent
   * @param {Object} interpretation - The interpretation details
   */
  async markPromptInterpreted(promptId, agentId, interpretation) {
    await this.prompts.doc(promptId).update({
      interpreted: true,
      interpretedBy: agentId,
      interpretedAt: admin.firestore.FieldValue.serverTimestamp(),
      interpretation: interpretation
    });
  }
  
  /**
   * Link activities to a prompt
   * @param {string} promptId - ID of the prompt
   * @param {Array} activityIds - Array of activity IDs
   */
  async linkActivitiesToPrompt(promptId, activityIds) {
    await this.prompts.doc(promptId).update({
      activities: admin.firestore.FieldValue.arrayUnion(...activityIds),
      status: 'in_progress'
    });
  }
}

/**
 * Q4D-Lenz Data Service
 * Manages data flow from Q4D-Lenz to Dream Commander and Co-Pilots
 */
class Q4DLenzDataService {
  constructor() {
    this.lenzProfiles = db.collection('q4dLenzProfiles');
    this.interpretations = db.collection('lenzInterpretations');
    this.linkedInData = db.collection('linkedInData');
  }
  
  /**
   * Store a Q4D-Lenz profile for an agent
   * @param {string} agentId - ID of the agent
   * @param {string} lenzType - Type of the lens (personal, professional, enterprise)
   * @param {Object} profile - The lens profile data
   * @returns {Promise<void>}
   */
  async storeLenzProfile(agentId, lenzType, profile) {
    await this.lenzProfiles.doc(agentId).set({
      agentId,
      lenzType,
      profile,
      created: admin.firestore.FieldValue.serverTimestamp(),
      updated: admin.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }
  
  /**
   * Get a Q4D-Lenz profile for an agent
   * @param {string} agentId - ID of the agent
   * @returns {Promise<Object>} - The lens profile
   */
  async getLenzProfile(agentId) {
    const doc = await this.lenzProfiles.doc(agentId).get();
    
    if (!doc.exists) {
      throw new Error(`Q4D-Lenz profile for agent ${agentId} not found`);
    }
    
    return doc.data();
  }
  
  /**
   * Store a prompt interpretation from Q4D-Lenz
   * @param {string} promptId - ID of the prompt
   * @param {string} agentId - ID of the interpreting agent
   * @param {Object} interpretation - The interpretation details
   * @returns {Promise<string>} - ID of the stored interpretation
   */
  async storeInterpretation(promptId, agentId, interpretation) {
    const interpretationData = {
      promptId,
      agentId,
      interpretation,
      created: admin.firestore.FieldValue.serverTimestamp(),
      potentialActivities: interpretation.potentialActivities || []
    };
    
    const docRef = await this.interpretations.add(interpretationData);
    
    // Index the interpretation in Pinecone for semantic search
    await this.indexInterpretationInPinecone(docRef.id, interpretationData);
    
    return docRef.id;
  }
  
  /**
   * Index an interpretation in Pinecone for semantic search
   * @param {string} interpretationId - ID of the interpretation
   * @param {Object} interpretation - The interpretation data
   */
  async indexInterpretationInPinecone(interpretationId, interpretation) {
    try {
      // Initialize Pinecone if not already initialized
      await pinecone.init({
        apiKey: functions.config().pinecone.apikey,
        environment: functions.config().pinecone.environment
      });
      
      // Generate embeddings for the interpretation
      const embeddings = await generateEmbeddings(
        JSON.stringify(interpretation.interpretation)
      );
      
      // Get the index
      const index = pinecone.Index(functions.config().pinecone.index);
      
      // Upsert the vector
      await index.upsert({
        vectors: [{
          id: interpretationId,
          values: embeddings,
          metadata: {
            type: 'interpretation',
            promptId: interpretation.promptId,
            agentId: interpretation.agentId,
            created: new Date().toISOString()
          }
        }]
      });
      
      console.log(`Indexed interpretation ${interpretationId} in Pinecone`);
    } catch (error) {
      console.error('Error indexing interpretation in Pinecone:', error);
      // Continue execution even if indexing fails
    }
  }
  
  /**
   * Store LinkedIn data from Dr. Match App
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {Object} linkedInData - The LinkedIn data
   * @returns {Promise<void>}
   */
  async storeLinkedInData(ownerSubscriberId, linkedInData) {
    await this.linkedInData.doc(ownerSubscriberId).set({
      ownerSubscriberId,
      linkedInData,
      fetchedAt: admin.firestore.FieldValue.serverTimestamp(),
      processed: false
    }, { merge: true });
  }
  
  /**
   * Get LinkedIn data for an owner-subscriber
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @returns {Promise<Object>} - The LinkedIn data
   */
  async getLinkedInData(ownerSubscriberId) {
    const doc = await this.linkedInData.doc(ownerSubscriberId).get();
    
    if (!doc.exists) {
      throw new Error(`LinkedIn data for owner ${ownerSubscriberId} not found`);
    }
    
    return doc.data().linkedInData;
  }
}

/**
 * Co-Pilot Data Service
 * Manages data flow for Co-Pilots
 */
class CoPilotDataService {
  constructor() {
    this.agents = db.collection('agents');
    this.activities = db.collection('activities');
    this.deliverables = db.collection('deliverables');
    this.authorizations = db.collection('authorizations');
    this.feedbacks = db.collection('feedbacks');
  }
  
  /**
   * Store an agent profile
   * @param {string} agentId - ID of the agent
   * @param {Object} profile - The agent profile
   * @returns {Promise<void>}
   */
  async storeAgentProfile(agentId, profile) {
    await this.agents.doc(agentId).set({
      ...profile,
      updated: admin.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }
  
  /**
   * Get an agent profile
   * @param {string} agentId - ID of the agent
   * @returns {Promise<Object>} - The agent profile
   */
  async getAgentProfile(agentId) {
    const doc = await this.agents.doc(agentId).get();
    
    if (!doc.exists) {
      throw new Error(`Agent ${agentId} not found`);
    }
    
    return doc.data();
  }
  
  /**
   * Create a new activity for a Co-Pilot
   * @param {Object} activity - The activity details
   * @param {string} agentId - ID of the executing agent
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {string} promptId - ID of the related prompt
   * @returns {Promise<string>} - ID of the created activity
   */
  async createActivity(activity, agentId, ownerSubscriberId, promptId) {
    const activityData = {
      ...activity,
      agentId,
      ownerSubscriberId,
      promptId,
      status: 'planned',
      created: admin.firestore.FieldValue.serverTimestamp(),
      updated: admin.firestore.FieldValue.serverTimestamp(),
      requiresApproval: activity.requiresApproval || false,
      approved: !activity.requiresApproval, // Auto-approve if no approval required
      deliverableId: null
    };
    
    const docRef = await this.activities.add(activityData);
    
    return docRef.id;
  }
  
  /**
   * Update activity status
   * @param {string} activityId - ID of the activity
   * @param {string} status - New status
   * @param {Object} additionalData - Additional data to update
   * @returns {Promise<void>}
   */
  async updateActivityStatus(activityId, status, additionalData = {}) {
    await this.activities.doc(activityId).update({
      status,
      updated: admin.firestore.FieldValue.serverTimestamp(),
      ...additionalData
    });
  }
  
  /**
   * Create a deliverable for an activity
   * @param {string} activityId - ID of the activity
   * @param {Object} deliverable - The deliverable data
   * @returns {Promise<string>} - ID of the created deliverable
   */
  async createDeliverable(activityId, deliverable) {
    const deliverableData = {
      activityId,
      ...deliverable,
      created: admin.firestore.FieldValue.serverTimestamp(),
      status: 'pending_authorization',
      authorized: false,
      authorizationQRCode: await generateQRCode(activityId)
    };
    
    const docRef = await this.deliverables.add(deliverableData);
    
    // Update the activity with the deliverable ID
    await this.activities.doc(activityId).update({
      deliverableId: docRef.id,
      status: 'completed',
      updated: admin.firestore.FieldValue.serverTimestamp()
    });
    
    return docRef.id;
  }
  
  /**
   * Process a deliverable authorization
   * @param {string} deliverableId - ID of the deliverable
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {Object} authorizationData - The authorization data
   * @returns {Promise<string>} - ID of the authorization
   */
  async processAuthorization(deliverableId, ownerSubscriberId, authorizationData) {
    // Verify the owner-subscriber is authorized to approve this deliverable
    const deliverable = await this.deliverables.doc(deliverableId).get();
    
    if (!deliverable.exists) {
      throw new Error(`Deliverable ${deliverableId} not found`);
    }
    
    const deliverableData = deliverable.data();
    const activity = await this.activities.doc(deliverableData.activityId).get();
    
    if (!activity.exists) {
      throw new Error(`Activity ${deliverableData.activityId} not found`);
    }
    
    const activityData = activity.data();
    
    if (activityData.ownerSubscriberId !== ownerSubscriberId) {
      throw new Error('Unauthorized authorization attempt');
    }
    
    // Create the authorization record
    const authorizationRecord = {
      deliverableId,
      ownerSubscriberId,
      ...authorizationData,
      authorized: true,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      blockchainTransactionId: await recordOnBlockchain(
        'authorization', 
        { deliverableId, ownerSubscriberId }
      )
    };
    
    const docRef = await this.authorizations.add(authorizationRecord);
    
    // Update the deliverable status
    await this.deliverables.doc(deliverableId).update({
      status: 'authorized',
      authorized: true,
      authorizationId: docRef.id,
      updated: admin.firestore.FieldValue.serverTimestamp()
    });
    
    return docRef.id;
  }
  
  /**
   * Store feedback for a deliverable
   * @param {string} deliverableId - ID of the deliverable
   * @param {string} ownerSubscriberId - ID of the owner-subscriber
   * @param {Object} feedbackData - The feedback data
   * @returns {Promise<string>} - ID of the created feedback
   */
  async storeFeedback(deliverableId, ownerSubscriberId, feedbackData) {
    const feedback = {
      deliverableId,
      ownerSubscriberId,
      